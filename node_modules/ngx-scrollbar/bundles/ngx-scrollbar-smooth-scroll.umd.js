(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/cdk/coercion'), require('@angular/cdk/platform'), require('rxjs'), require('rxjs/operators'), require('bezier-easing')) :
    typeof define === 'function' && define.amd ? define('ngx-scrollbar/smooth-scroll', ['exports', '@angular/core', '@angular/common', '@angular/cdk/coercion', '@angular/cdk/platform', 'rxjs', 'rxjs/operators', 'bezier-easing'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['ngx-scrollbar'] = global['ngx-scrollbar'] || {}, global['ngx-scrollbar']['smooth-scroll'] = {}), global.ng.core, global.ng.common, global.ng.cdk.coercion, global.ng.cdk.platform, global.rxjs, global.rxjs.operators, global['bezier-easing']));
}(this, (function (exports, i0, i1, coercion, platform, rxjs, operators, BezierEasing) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var BezierEasing__default = /*#__PURE__*/_interopDefaultLegacy(BezierEasing);

    var SMOOTH_SCROLL_OPTIONS = new i0.InjectionToken('SMOOTH_SCROLL_OPTIONS');

    // @dynamic
    var SmoothScrollManager = /** @class */ (function () {
        function SmoothScrollManager(_document, _platform, customDefaultOptions) {
            this._document = _document;
            this._platform = _platform;
            // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.
            // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
            // Purpose: If user called a scroll function again on the same element before the scrolls completes,
            // it cancels the ongoing scroll and starts a new one
            this._onGoingScrolls = new Map();
            this._defaultOptions = Object.assign({ duration: 468, easing: {
                    x1: 0.42,
                    y1: 0,
                    x2: 0.58,
                    y2: 1
                } }, customDefaultOptions);
        }
        Object.defineProperty(SmoothScrollManager.prototype, "_w", {
            get: function () {
                return this._document.defaultView;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SmoothScrollManager.prototype, "_now", {
            /**
             * Timing method
             */
            get: function () {
                return this._w.performance && this._w.performance.now
                    ? this._w.performance.now.bind(this._w.performance)
                    : Date.now;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * changes scroll position inside an element
         */
        SmoothScrollManager.prototype._scrollElement = function (el, x, y) {
            el.scrollLeft = x;
            el.scrollTop = y;
        };
        /**
         * Handles a given parameter of type HTMLElement, ElementRef or selector
         */
        SmoothScrollManager.prototype._getElement = function (el, parent) {
            if (typeof el === 'string') {
                return (parent || this._document).querySelector(el);
            }
            return coercion.coerceElement(el);
        };
        /**
         * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
         */
        SmoothScrollManager.prototype._initSmoothScroll = function (el) {
            if (this._onGoingScrolls.has(el)) {
                this._onGoingScrolls.get(el).next();
            }
            return this._onGoingScrolls.set(el, new rxjs.Subject()).get(el);
        };
        /**
         * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
         */
        SmoothScrollManager.prototype._isFinished = function (context, destroyed, resolve) {
            if (context.currentX !== context.x || context.currentY !== context.y) {
                return true;
            }
            destroyed.next();
            resolve();
            return false;
        };
        /**
         * Terminates an ongoing smooth scroll
         */
        SmoothScrollManager.prototype._interrupted = function (el, destroyed) {
            return rxjs.merge(rxjs.fromEvent(el, 'wheel', { passive: true, capture: true }), rxjs.fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(operators.take(1));
        };
        /**
         * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
         */
        SmoothScrollManager.prototype._destroy = function (el, destroyed) {
            destroyed.complete();
            this._onGoingScrolls.delete(el);
        };
        /**
         * A function called recursively that, given a context, steps through scrolling
         */
        SmoothScrollManager.prototype._step = function (context) {
            var _this = this;
            return new rxjs.Observable(function (subscriber) {
                var elapsed = (_this._now() - context.startTime) / context.duration;
                // avoid elapsed times higher than one
                elapsed = elapsed > 1 ? 1 : elapsed;
                // apply easing to elapsed time
                var value = context.easing(elapsed);
                context.currentX = context.startX + (context.x - context.startX) * value;
                context.currentY = context.startY + (context.y - context.startY) * value;
                _this._scrollElement(context.scrollable, context.currentX, context.currentY);
                // Proceed to the step
                rxjs.animationFrameScheduler.schedule(function () { return subscriber.next(context); });
            });
        };
        SmoothScrollManager.prototype._applyScrollToOptions = function (el, options) {
            var _this = this;
            if (!options.duration) {
                this._scrollElement(el, options.left, options.top);
                return Promise.resolve();
            }
            // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
            var destroyed = this._initSmoothScroll(el);
            var context = {
                scrollable: el,
                startTime: this._now(),
                startX: el.scrollLeft,
                startY: el.scrollTop,
                x: options.left == null ? el.scrollLeft : ~~options.left,
                y: options.top == null ? el.scrollTop : ~~options.top,
                duration: options.duration,
                easing: BezierEasing__default['default'](options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
            };
            return new Promise(function (resolve) {
                // Scroll each step recursively
                rxjs.of(null).pipe(operators.expand(function () { return _this._step(context).pipe(operators.takeWhile(function (currContext) { return _this._isFinished(currContext, destroyed, resolve); })); }), operators.takeUntil(_this._interrupted(el, destroyed)), operators.finalize(function () { return _this._destroy(el, destroyed); })).subscribe();
            });
        };
        /**
         * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
         * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
         * left and right always refer to the left and right side of the scrolling container irrespective
         * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
         * in an RTL context.
         * @param scrollable element
         * @param customOptions specified the offsets to scroll to.
         */
        SmoothScrollManager.prototype.scrollTo = function (scrollable, customOptions) {
            if (i1.isPlatformBrowser(this._platform)) {
                var el = this._getElement(scrollable);
                var isRtl = getComputedStyle(el).direction === 'rtl';
                var rtlScrollAxisType = platform.getRtlScrollAxisType();
                var options = Object.assign(Object.assign(Object.assign({}, this._defaultOptions), customOptions), {
                    // Rewrite start & end offsets as right or left offsets.
                    left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,
                    right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right
                });
                // Rewrite the bottom offset as a top offset.
                if (options.bottom != null) {
                    options.top = el.scrollHeight - el.clientHeight - options.bottom;
                }
                // Rewrite the right offset as a left offset.
                if (isRtl && rtlScrollAxisType !== 0 /* NORMAL */) {
                    if (options.left != null) {
                        options.right = el.scrollWidth - el.clientWidth - options.left;
                    }
                    if (rtlScrollAxisType === 2 /* INVERTED */) {
                        options.left = options.right;
                    }
                    else if (rtlScrollAxisType === 1 /* NEGATED */) {
                        options.left = options.right ? -options.right : options.right;
                    }
                }
                else {
                    if (options.right != null) {
                        options.left = el.scrollWidth - el.clientWidth - options.right;
                    }
                }
                return this._applyScrollToOptions(el, options);
            }
            return Promise.resolve();
        };
        /**
         * Scroll to element by reference or selector
         */
        SmoothScrollManager.prototype.scrollToElement = function (scrollable, target, customOptions) {
            if (customOptions === void 0) { customOptions = {}; }
            var scrollableEl = this._getElement(scrollable);
            var targetEl = this._getElement(target, scrollableEl);
            var options = Object.assign(Object.assign({}, customOptions), {
                left: targetEl.offsetLeft + (customOptions.left || 0),
                top: targetEl.offsetTop + (customOptions.top || 0)
            });
            return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();
        };
        return SmoothScrollManager;
    }());
    SmoothScrollManager.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function SmoothScrollManager_Factory() { return new SmoothScrollManager(i0__namespace.ɵɵinject(i1__namespace.DOCUMENT), i0__namespace.ɵɵinject(i0__namespace.PLATFORM_ID), i0__namespace.ɵɵinject(SMOOTH_SCROLL_OPTIONS, 8)); }, token: SmoothScrollManager, providedIn: "root" });
    SmoothScrollManager.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    SmoothScrollManager.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] },
        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [SMOOTH_SCROLL_OPTIONS,] }] }
    ]; };

    var SmoothScroll = /** @class */ (function () {
        function SmoothScroll(element, smoothScroll) {
            this.element = element;
            this.smoothScroll = smoothScroll;
        }
        SmoothScroll.prototype.scrollTo = function (options) {
            return this.smoothScroll.scrollTo(this.element, options);
        };
        SmoothScroll.prototype.scrollToElement = function (target, options) {
            return this.smoothScroll.scrollToElement(this.element, target, options);
        };
        return SmoothScroll;
    }());
    SmoothScroll.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[smoothScroll], [smooth-scroll]',
                    exportAs: 'smoothScroll'
                },] }
    ];
    SmoothScroll.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: SmoothScrollManager }
    ]; };

    var SmoothScrollModule = /** @class */ (function () {
        function SmoothScrollModule() {
        }
        return SmoothScrollModule;
    }());
    SmoothScrollModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [SmoothScroll],
                    exports: [SmoothScroll]
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.SMOOTH_SCROLL_OPTIONS = SMOOTH_SCROLL_OPTIONS;
    exports.SmoothScroll = SmoothScroll;
    exports.SmoothScrollManager = SmoothScrollManager;
    exports.SmoothScrollModule = SmoothScrollModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-scrollbar-smooth-scroll.umd.js.map
