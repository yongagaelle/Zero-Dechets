(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/cdk/bidi'), require('@angular/cdk/portal'), require('@angular/cdk/platform'), require('ngx-scrollbar/smooth-scroll'), require('@angular/cdk/coercion'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('ngx-scrollbar', ['exports', '@angular/core', '@angular/common', '@angular/cdk/bidi', '@angular/cdk/portal', '@angular/cdk/platform', 'ngx-scrollbar/smooth-scroll', '@angular/cdk/coercion', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-scrollbar'] = {}, global.ng.core, global.ng.common, global.ng.cdk.bidi, global.ng.cdk.portal, global.ng.cdk.platform, global['ngx-scrollbar']['smooth-scroll'], global.ng.cdk.coercion, global.rxjs, global.rxjs.operators));
}(this, (function (exports, i0, i1, bidi, portal, i3, smoothScroll, coercion, rxjs, operators) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var i3__namespace = /*#__PURE__*/_interopNamespace(i3);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    function preventSelection(doc) {
        return operators.tap(function () {
            doc.onselectstart = function () { return false; };
        });
    }
    function enableSelection(doc) {
        return operators.tap(function () {
            doc.onselectstart = null;
        });
    }
    function stopPropagation() {
        return operators.tap(function (e) { return e.stopPropagation(); });
    }
    /**
     * Check if pointer is within scrollbar bounds
     */
    function isWithinBounds(e, rect) {
        return (e.clientX >= rect.left &&
            e.clientX <= rect.left + rect.width &&
            e.clientY >= rect.top &&
            e.clientY <= rect.top + rect.height);
    }

    var ScrollViewport = /** @class */ (function () {
        function ScrollViewport(viewPort) {
            this.viewPort = viewPort;
            this.nativeElement = viewPort.nativeElement;
        }
        Object.defineProperty(ScrollViewport.prototype, "clientHeight", {
            // Get viewport size, clientHeight or clientWidth
            get: function () {
                return this.nativeElement.clientHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "clientWidth", {
            get: function () {
                return this.nativeElement.clientWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "scrollHeight", {
            get: function () {
                return this.nativeElement.scrollHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "scrollWidth", {
            get: function () {
                return this.nativeElement.scrollWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "scrollTop", {
            // Get viewport scroll offset, scrollTop or scrollLeft
            get: function () {
                return this.nativeElement.scrollTop;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "scrollLeft", {
            get: function () {
                return this.nativeElement.scrollLeft;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "scrollMaxX", {
            // Get the available scrollable size
            get: function () {
                return this.scrollWidth - this.clientWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "scrollMaxY", {
            get: function () {
                return this.scrollHeight - this.clientHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "contentHeight", {
            get: function () {
                var _a;
                return ((_a = this.contentWrapperElement) === null || _a === void 0 ? void 0 : _a.clientHeight) || 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "contentWidth", {
            get: function () {
                var _a;
                return ((_a = this.contentWrapperElement) === null || _a === void 0 ? void 0 : _a.clientWidth) || 0;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Activate viewport pointer events such as 'hovered' and 'clicked' events
         */
        ScrollViewport.prototype.activatePointerEvents = function (propagate, destroyed) {
            var _this = this;
            this.hovered = new rxjs.Observable(function (subscriber) {
                // Stream that emits when pointer is moved over the viewport (used to set the hovered state)
                var mouseMoveStream = rxjs.fromEvent(_this.nativeElement, 'mousemove', { passive: true });
                var mouseMove = propagate ? mouseMoveStream : mouseMoveStream.pipe(stopPropagation());
                // Stream that emits when pointer leaves the viewport (used to remove the hovered state)
                var mouseLeave = rxjs.fromEvent(_this.nativeElement, 'mouseleave').pipe(operators.map(function () { return false; }));
                rxjs.merge(mouseMove, mouseLeave).pipe(operators.tap(function (e) { return subscriber.next(e); }), operators.takeUntil(destroyed)).subscribe();
            });
            this.clicked = new rxjs.Observable(function (subscriber) {
                var mouseDown = rxjs.fromEvent(_this.nativeElement, 'mousedown', { passive: true }).pipe(operators.tap(function (e) { return subscriber.next(e); }));
                var mouseUp = rxjs.fromEvent(_this.nativeElement, 'mouseup', { passive: true }).pipe(operators.tap(function () { return subscriber.next(false); }));
                mouseDown.pipe(operators.switchMap(function () { return mouseUp; }), operators.takeUntil(destroyed)).subscribe();
            });
        };
        /**
         * Set this directive as a non-functional wrapper, called when a custom viewport is used
         */
        ScrollViewport.prototype.setAsWrapper = function () {
            // In this case the default viewport and the default content wrapper will act as a mask
            this.nativeElement.className = 'ng-native-scrollbar-hider ng-scroll-layer';
            if (this.nativeElement.firstElementChild) {
                this.nativeElement.firstElementChild.className = 'ng-scroll-layer';
            }
        };
        /**
         * Set this directive as  the viewport, called when no custom viewport is used
         */
        ScrollViewport.prototype.setAsViewport = function (customClassName) {
            this.nativeElement.className = "ng-native-scrollbar-hider ng-scroll-viewport " + customClassName;
            // Check if the custom viewport has only one child and set it as the content wrapper
            if (this.nativeElement.firstElementChild) {
                this.contentWrapperElement = this.nativeElement.firstElementChild;
                this.contentWrapperElement.classList.add('ng-scroll-content');
            }
        };
        /**
         * Scroll viewport vertically
         */
        ScrollViewport.prototype.scrollYTo = function (value) {
            this.nativeElement.scrollTop = value;
        };
        /**
         * Scroll viewport horizontally
         */
        ScrollViewport.prototype.scrollXTo = function (value) {
            this.nativeElement.scrollLeft = value;
        };
        return ScrollViewport;
    }());
    ScrollViewport.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[scrollViewport]'
                },] }
    ];
    ScrollViewport.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var NG_SCROLLBAR_OPTIONS = new i0.InjectionToken('NG_SCROLLBAR_OPTIONS');

    var defaultOptions = {
        viewClass: '',
        trackClass: '',
        thumbClass: '',
        track: 'vertical',
        appearance: 'compact',
        visibility: 'native',
        position: 'native',
        pointerEventsMethod: 'viewport',
        trackClickScrollDuration: 300,
        minThumbSize: 20,
        windowResizeDebounce: 0,
        sensorDebounce: 0,
        scrollAuditTime: 0,
        viewportPropagateMouseMove: true,
        autoHeightDisabled: true,
        autoWidthDisabled: true,
        sensorDisabled: false,
        pointerEventsDisabled: false
    };
    var ScrollbarManager = /** @class */ (function () {
        function ScrollbarManager(options) {
            this.globalOptions = options ? Object.assign(Object.assign({}, defaultOptions), options) : defaultOptions;
            this.rtlScrollAxisType = i3.getRtlScrollAxisType();
        }
        return ScrollbarManager;
    }());
    ScrollbarManager.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ScrollbarManager_Factory() { return new ScrollbarManager(i0__namespace.ɵɵinject(NG_SCROLLBAR_OPTIONS, 8)); }, token: ScrollbarManager, providedIn: "root" });
    ScrollbarManager.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    ScrollbarManager.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [NG_SCROLLBAR_OPTIONS,] }] }
    ]; };

    var NgScrollbar = /** @class */ (function () {
        function NgScrollbar(el, zone, changeDetectorRef, dir, smoothScroll, manager) {
            this.el = el;
            this.zone = zone;
            this.changeDetectorRef = changeDetectorRef;
            this.dir = dir;
            this.smoothScroll = smoothScroll;
            this.manager = manager;
            this._disabled = false;
            this._sensorDisabled = this.manager.globalOptions.sensorDisabled;
            this._pointerEventsDisabled = this.manager.globalOptions.pointerEventsDisabled;
            this._autoHeightDisabled = this.manager.globalOptions.autoHeightDisabled;
            this._autoWidthDisabled = this.manager.globalOptions.autoWidthDisabled;
            this._viewportPropagateMouseMove = this.manager.globalOptions.viewportPropagateMouseMove;
            /** A class forwarded to scrollable viewport element */
            this.viewClass = this.manager.globalOptions.viewClass;
            /** A class forwarded to the scrollbar track element */
            this.trackClass = this.manager.globalOptions.trackClass;
            /** A class forwarded to the scrollbar thumb element */
            this.thumbClass = this.manager.globalOptions.thumbClass;
            /** Minimum scrollbar thumb size */
            this.minThumbSize = this.manager.globalOptions.minThumbSize;
            /** The duration which the scrolling takes to reach its target when scrollbar rail is clicked */
            this.trackClickScrollDuration = this.manager.globalOptions.trackClickScrollDuration;
            /**
             * Sets the pointer events method
             * Use viewport pointer events  to handle dragging and track click (This makes scrolling work when mouse is over the scrollbar)
             * Use scrollbar pointer events to handle dragging and track click
             */
            this.pointerEventsMethod = this.manager.globalOptions.pointerEventsMethod;
            /**
             * Sets the supported scroll track of the viewport, there are 3 options:
             *
             * - `vertical` Use both vertical and horizontal scrollbar
             * - `horizontal` Use both vertical and horizontal scrollbar
             * - `all` Use both vertical and horizontal scrollbar
             */
            this.track = this.manager.globalOptions.track;
            /**
             * When to show the scrollbar, and there are 3 options:
             *
             * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar
             * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
             * - `always` Scrollbars are always shown even if the viewport is not scrollable
             */
            this.visibility = this.manager.globalOptions.visibility;
            /**
             *  Sets the appearance of the scrollbar, there are 2 options:
             *
             * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.
             * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
             */
            this.appearance = this.manager.globalOptions.appearance;
            /**
             * Sets the position of each scrollbar, there are 4 options:
             *
             * - `native` (Default) Use the default position like in native scrollbar.
             * - `invertY` Inverts vertical scrollbar position
             * - `invertX` Inverts Horizontal scrollbar position
             * - `invertAll` Inverts both scrollbar positions
             */
            this.position = this.manager.globalOptions.position;
            /** Debounce interval for detecting changes via ResizeObserver */
            this.sensorDebounce = this.manager.globalOptions.sensorDebounce;
            /** Scroll Audit Time */
            this.scrollAuditTime = this.manager.globalOptions.scrollAuditTime;
            /** Steam that emits when scrollbar is updated */
            this.updated = new i0.EventEmitter();
            /** Set of attributes added on the scrollbar wrapper */
            this.state = {};
            /** Stream that destroys components' observables */
            this.destroyed = new rxjs.Subject();
        }
        Object.defineProperty(NgScrollbar.prototype, "disabled", {
            /** Disable custom scrollbar and switch back to native scrollbar */
            get: function () {
                return this._disabled;
            },
            set: function (disabled) {
                this._disabled = coercion.coerceBooleanProperty(disabled);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgScrollbar.prototype, "sensorDisabled", {
            /** Whether ResizeObserver is disabled */
            get: function () {
                return this._sensorDisabled;
            },
            set: function (disabled) {
                this._sensorDisabled = coercion.coerceBooleanProperty(disabled);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgScrollbar.prototype, "pointerEventsDisabled", {
            /** A flag used to enable/disable the scrollbar thumb dragged event */
            get: function () {
                return this._pointerEventsDisabled;
            },
            set: function (disabled) {
                this._pointerEventsDisabled = coercion.coerceBooleanProperty(disabled);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgScrollbar.prototype, "viewportPropagateMouseMove", {
            /** Enable viewport mousemove event propagation (only when pointerEventsMethod="viewport") */
            get: function () {
                return this._viewportPropagateMouseMove;
            },
            set: function (disabled) {
                this._viewportPropagateMouseMove = coercion.coerceBooleanProperty(disabled);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgScrollbar.prototype, "autoHeightDisabled", {
            /** Disable auto-height */
            get: function () {
                return this._autoHeightDisabled;
            },
            set: function (disabled) {
                this._autoHeightDisabled = coercion.coerceBooleanProperty(disabled);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgScrollbar.prototype, "autoWidthDisabled", {
            /** Disable auto-width */
            get: function () {
                return this._autoWidthDisabled;
            },
            set: function (disabled) {
                this._autoWidthDisabled = coercion.coerceBooleanProperty(disabled);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgScrollbar.prototype, "nativeElement", {
            get: function () {
                return this.el.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Update local state with each change detection
         */
        NgScrollbar.prototype.updateState = function () {
            var verticalUsed = false;
            var horizontalUsed = false;
            var isVerticallyScrollable = false;
            var isHorizontallyScrollable = false;
            // Check if vertical scrollbar should be displayed
            if (this.track === 'all' || this.track === 'vertical') {
                isVerticallyScrollable = this.viewport.scrollHeight > this.viewport.clientHeight;
                verticalUsed = this.visibility === 'always' || isVerticallyScrollable;
            }
            // Check if horizontal scrollbar should be displayed
            if (this.track === 'all' || this.track === 'horizontal') {
                isHorizontallyScrollable = this.viewport.scrollWidth > this.viewport.clientWidth;
                horizontalUsed = this.visibility === 'always' || isHorizontallyScrollable;
            }
            // Update inner wrapper attributes
            this.setState({
                position: this.position,
                track: this.track,
                appearance: this.appearance,
                visibility: this.visibility,
                deactivated: this.disabled,
                dir: this.dir.value,
                pointerEventsMethod: this.pointerEventsMethod,
                verticalUsed: verticalUsed,
                horizontalUsed: horizontalUsed,
                isVerticallyScrollable: isVerticallyScrollable,
                isHorizontallyScrollable: isHorizontallyScrollable
            });
        };
        NgScrollbar.prototype.setState = function (state) {
            this.state = Object.assign(Object.assign({}, this.state), state);
            this.changeDetectorRef.detectChanges();
        };
        NgScrollbar.prototype.getScrolledByDirection = function (property) {
            var event;
            return this.scrolled.pipe(operators.tap(function (e) { return event = e; }), operators.pluck('target', property), operators.pairwise(), operators.filter(function (_a) {
                var _b = __read(_a, 2), prev = _b[0], curr = _b[1];
                return prev !== curr;
            }), operators.map(function () { return event; }));
        };
        /**
         * Set hovered state if a scrollbar is being hovered
         */
        NgScrollbar.prototype.setHovered = function (hovered) {
            var _this = this;
            this.zone.run(function () { return _this.setState(Object.assign({}, hovered)); });
        };
        /**
         * Set dragging state if a scrollbar is being dragged
         */
        NgScrollbar.prototype.setDragging = function (dragging) {
            var _this = this;
            this.zone.run(function () { return _this.setState(Object.assign({}, dragging)); });
        };
        /**
         * Set clicked state if a scrollbar track is being click
         */
        NgScrollbar.prototype.setClicked = function (scrollbarClicked) {
            var _this = this;
            this.zone.run(function () { return _this.setState({ scrollbarClicked: scrollbarClicked }); });
        };
        NgScrollbar.prototype.ngOnInit = function () {
            var _this = this;
            // Set the viewport based on user choice
            this.zone.runOutsideAngular(function () {
                if (_this.customViewPort) {
                    _this.viewport = _this.customViewPort;
                    _this.defaultViewPort.setAsWrapper();
                }
                else {
                    _this.viewport = _this.defaultViewPort;
                }
                // Activate the selected viewport
                _this.viewport.setAsViewport(_this.viewClass);
                var scrollStream = rxjs.fromEvent(_this.viewport.nativeElement, 'scroll', { passive: true });
                // Throttle scroll event if 'scrollAuditTime' is set
                scrollStream = _this.scrollAuditTime ? scrollStream.pipe(operators.auditTime(_this.scrollAuditTime)) : scrollStream;
                // Initialize scroll streams
                _this.scrolled = scrollStream.pipe(operators.takeUntil(_this.destroyed));
                _this.verticalScrolled = _this.getScrolledByDirection('scrollTop');
                _this.horizontalScrolled = _this.getScrolledByDirection('scrollLeft');
            });
        };
        NgScrollbar.prototype.ngOnChanges = function (changes) {
            // Update only when the viewport is initialized
            if (this.viewport) {
                this.update();
            }
        };
        NgScrollbar.prototype.ngAfterViewInit = function () {
            var _this = this;
            // Initial update
            this.update();
            // Update on dir changes
            this.dir.change.pipe(operators.tap(function () { return _this.update(); }), operators.takeUntil(this.destroyed)).subscribe();
        };
        NgScrollbar.prototype.ngOnDestroy = function () {
            this.destroyed.next();
            this.destroyed.complete();
        };
        /**
         * Update local state and the internal scrollbar controls
         */
        NgScrollbar.prototype.update = function () {
            if (!this.autoHeightDisabled) {
                this.updateHeight();
            }
            if (!this.autoWidthDisabled) {
                this.updateWidth();
            }
            // Re-evaluate the state after setting height or width
            this.updateState();
            this.updated.next();
        };
        /**
         * Smooth scroll functions
         */
        NgScrollbar.prototype.scrollTo = function (options) {
            return this.smoothScroll.scrollTo(this.viewport.nativeElement, options);
        };
        /**
         * Scroll to element by reference or selector
         */
        NgScrollbar.prototype.scrollToElement = function (target, options) {
            return this.smoothScroll.scrollToElement(this.viewport.nativeElement, target, options);
        };
        NgScrollbar.prototype.updateHeight = function () {
            // Auto-height: Set component height to content height
            if (this.appearance === 'standard' && this.scrollbarX) {
                // if scrollbar-x is displayed in standard mode
                this.nativeElement.style.height = this.viewport.contentHeight + this.scrollbarX.nativeElement.clientHeight + "px";
            }
            else {
                this.nativeElement.style.height = this.viewport.contentHeight + "px";
            }
        };
        NgScrollbar.prototype.updateWidth = function () {
            // Auto-width: Set component minWidth to content width
            if (this.appearance === 'standard' && this.scrollbarY) {
                // if scrollbar-y is displayed in standard mode
                this.nativeElement.style.width = this.viewport.contentWidth + this.scrollbarY.nativeElement.clientWidth + "px";
            }
            else {
                this.nativeElement.style.width = this.viewport.contentWidth + "px";
            }
        };
        return NgScrollbar;
    }());
    NgScrollbar.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ng-scrollbar',
                    exportAs: 'ngScrollbar',
                    template: "<div class=\"ng-scrollbar-wrapper\" [ngAttr]=\"state\">\n  <div class=\"ng-scroll-viewport-wrapper\"\n       (resizeSensor)=\"update()\"\n       [sensorDebounce]=\"sensorDebounce\"\n       [sensorDisabled]=\"sensorDisabled\">\n    <div scrollViewport\n         hideNativeScrollbar>\n      <div>\n        <ng-content></ng-content>\n      </div>\n    </div>\n  </div>\n  <ng-container *ngIf=\"!disabled\">\n    <scrollbar-x #scrollbarX\n                 *ngIf=\"state.horizontalUsed\"\n                 [attr.scrollable]=\"state.isHorizontallyScrollable\"\n                 [attr.fit]=\"state.verticalUsed\">\n    </scrollbar-x>\n    <scrollbar-y #scrollbarY\n                 *ngIf=\"state.verticalUsed\"\n                 [attr.scrollable]=\"state.isVerticallyScrollable\"\n                 [attr.fit]=\"state.horizontalUsed\">\n    </scrollbar-y>\n  </ng-container>\n</div>\n\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    host: { '[class.ng-scrollbar]': 'true' },
                    styles: ["::ng-deep .ng-scrollbar-measure{scrollbar-width:none;-ms-overflow-style:none}::ng-deep .ng-scrollbar-measure::-webkit-scrollbar{display:none}:host{--scrollbar-border-radius:7px;--scrollbar-padding:4px;--scrollbar-track-color:transparent;--scrollbar-thumb-color:rgba(0,0,0,0.2);--scrollbar-thumb-hover-color:var(--scrollbar-thumb-color);--scrollbar-size:5px;--scrollbar-hover-size:var(--scrollbar-size);--scrollbar-overscroll-behavior:initial;--scrollbar-transition-duration:400ms;--scrollbar-transition-delay:800ms;--scrollbar-thumb-transition:height ease-out 150ms,width ease-out 150ms;--scrollbar-track-transition:height ease-out 150ms,width ease-out 150ms;display:block;position:relative;height:100%;max-height:100%;max-width:100%;box-sizing:content-box!important}:host>.ng-scrollbar-wrapper{--scrollbar-total-size:calc(var(--scrollbar-size) + var(--scrollbar-padding) * 2);--vertical-scrollbar-size:var(--scrollbar-size);--horizontal-scrollbar-size:var(--scrollbar-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2)}:host>.ng-scrollbar-wrapper[verticalDragging=true],:host>.ng-scrollbar-wrapper[verticalHovered=true]{--vertical-scrollbar-size:var(--scrollbar-hover-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[horizontalDragging=true],:host>.ng-scrollbar-wrapper[horizontalHovered=true]{--horizontal-scrollbar-size:var(--scrollbar-hover-size);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:0;right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:var(--scrollbar-total-size);right:0}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:var(--scrollbar-total-size);right:0}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:0;right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{top:0;bottom:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-bottom:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{top:var(--scrollbar-total-size);bottom:0}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-top:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{scrollbar-width:none;-ms-overflow-style:none}:host>.ng-scrollbar-wrapper[deactivated=false]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport::-webkit-scrollbar,:host>.ng-scrollbar-wrapper[deactivated=false]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport::-webkit-scrollbar{display:none}:host>.ng-scrollbar-wrapper[deactivated=false][horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-native-scrollbar-hider,:host>.ng-scrollbar-wrapper[deactivated=false][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-native-scrollbar-hider{bottom:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[deactivated=false][verticalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-native-scrollbar-hider,:host>.ng-scrollbar-wrapper[deactivated=false][verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-native-scrollbar-hider{left:0;right:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-native-scrollbar-hider,:host>.ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-native-scrollbar-hider{right:0;left:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]>.scrollbar-control{opacity:0;transition-property:opacity;transition-duration:var(--scrollbar-transition-duration);transition-delay:var(--scrollbar-transition-delay)}:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]:active>.scrollbar-control,:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]:focus>.scrollbar-control,:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]:hover>.scrollbar-control{opacity:1;transition-duration:var(--scrollbar-transition-duration);transition-delay:0ms}:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-x:auto;overflow-y:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-y:auto;overflow-x:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow:auto}.ng-scroll-viewport-wrapper{overflow:hidden}.ng-scroll-viewport{-webkit-overflow-scrolling:touch;contain:strict;will-change:scroll-position;overscroll-behavior:var(--scrollbar-overscroll-behavior)}::ng-deep .ng-scroll-content{position:relative!important;display:inline-block;min-width:100%}.ng-scroll-layer,.ng-scroll-viewport-wrapper,.ng-scrollbar-wrapper,::ng-deep .ng-scroll-viewport{position:absolute;left:0;right:0;top:0;bottom:0}", "::ng-deep .ng-scrollbar-wrapper[pointerEventsMethod=viewport]>.scrollbar-control{pointer-events:none}::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{-webkit-user-select:none;-moz-user-select:none;user-select:none}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control{position:absolute;display:flex;justify-content:center;align-items:center;transition:var(--scrollbar-track-transition)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[scrollable=false] .ng-scrollbar-thumb{display:none}::ng-deep .ng-scrollbar-track{height:100%;width:100%;z-index:1;border-radius:var(--scrollbar-border-radius);background-color:var(--scrollbar-track-color);overflow:hidden;transition:var(--scrollbar-track-transition);cursor:default}::ng-deep .ng-scrollbar-thumb{box-sizing:border-box;position:relative;border-radius:inherit;background-color:var(--scrollbar-thumb-color);transform:translateZ(0);transition:var(--scrollbar-thumb-transition)}"]
                },] }
    ];
    NgScrollbar.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.NgZone },
        { type: i0.ChangeDetectorRef },
        { type: bidi.Directionality },
        { type: smoothScroll.SmoothScrollManager },
        { type: ScrollbarManager }
    ]; };
    NgScrollbar.propDecorators = {
        disabled: [{ type: i0.Input }],
        sensorDisabled: [{ type: i0.Input }],
        pointerEventsDisabled: [{ type: i0.Input }],
        viewportPropagateMouseMove: [{ type: i0.Input }],
        autoHeightDisabled: [{ type: i0.Input }],
        autoWidthDisabled: [{ type: i0.Input }],
        viewClass: [{ type: i0.Input }],
        trackClass: [{ type: i0.Input }],
        thumbClass: [{ type: i0.Input }],
        minThumbSize: [{ type: i0.Input }],
        trackClickScrollDuration: [{ type: i0.Input }],
        pointerEventsMethod: [{ type: i0.Input }],
        track: [{ type: i0.Input }],
        visibility: [{ type: i0.Input }],
        appearance: [{ type: i0.Input }],
        position: [{ type: i0.Input }],
        sensorDebounce: [{ type: i0.Input }],
        scrollAuditTime: [{ type: i0.Input }],
        updated: [{ type: i0.Output }],
        scrollbarY: [{ type: i0.ViewChild, args: ['scrollbarY', { read: i0.ElementRef },] }],
        scrollbarX: [{ type: i0.ViewChild, args: ['scrollbarX', { read: i0.ElementRef },] }],
        defaultViewPort: [{ type: i0.ViewChild, args: [ScrollViewport, { static: true },] }],
        customViewPort: [{ type: i0.ContentChild, args: [ScrollViewport, { static: true },] }]
    };

    var NativeScrollbarSizeFactory = /** @class */ (function () {
        function NativeScrollbarSizeFactory(document, manager, platform) {
            var _this = this;
            this.document = document;
            this.manager = manager;
            this.platform = platform;
            this._scrollbarSize = new rxjs.BehaviorSubject(this.getNativeScrollbarSize());
            this.scrollbarSize = this._scrollbarSize.asObservable();
            // Calculate native scrollbar size on window resize event, because the size changes if use zoomed in/out
            if (platform.isBrowser) {
                rxjs.fromEvent(this.document.defaultView, 'resize', { passive: true }).pipe(operators.debounceTime(this.manager.globalOptions.windowResizeDebounce), operators.map(function () { return _this.getNativeScrollbarSize(); }), operators.distinctUntilChanged(), operators.tap(function (size) { return _this._scrollbarSize.next(size); })).subscribe();
            }
        }
        /**
         * Get native scrollbar size
         */
        NativeScrollbarSizeFactory.prototype.getNativeScrollbarSize = function () {
            // Avoid executing browser code in server side rendering
            if (!this.platform.isBrowser) {
                return 0;
            }
            // Hide iOS browsers native scrollbar
            if (this.platform.IOS) {
                return 6;
            }
            var box = this.document.createElement('div');
            box.className = 'ng-scrollbar-measure';
            box.style.left = 0;
            box.style.overflow = 'scroll';
            box.style.position = 'fixed';
            box.style.top = '-9999px';
            this.document.body.appendChild(box);
            var size = box.getBoundingClientRect().right;
            this.document.body.removeChild(box);
            return size;
        };
        return NativeScrollbarSizeFactory;
    }());
    NativeScrollbarSizeFactory.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function NativeScrollbarSizeFactory_Factory() { return new NativeScrollbarSizeFactory(i0__namespace.ɵɵinject(i1__namespace.DOCUMENT), i0__namespace.ɵɵinject(ScrollbarManager), i0__namespace.ɵɵinject(i3__namespace.Platform)); }, token: NativeScrollbarSizeFactory, providedIn: "root" });
    NativeScrollbarSizeFactory.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    NativeScrollbarSizeFactory.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] },
        { type: ScrollbarManager },
        { type: i3.Platform }
    ]; };

    var HideNativeScrollbar = /** @class */ (function () {
        function HideNativeScrollbar(el, renderer, hideNativeScrollbar) {
            var _this = this;
            this.renderer = renderer;
            this.hideNativeScrollbar = hideNativeScrollbar;
            this._subscriber = rxjs.Subscription.EMPTY;
            this._subscriber = hideNativeScrollbar.scrollbarSize.subscribe(function (size) {
                _this.renderer.setStyle(el.nativeElement, '--native-scrollbar-size', "-" + size + "px", i0.RendererStyleFlags2.DashCase);
            });
        }
        HideNativeScrollbar.prototype.ngOnDestroy = function () {
            this._subscriber.unsubscribe();
        };
        return HideNativeScrollbar;
    }());
    HideNativeScrollbar.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[hideNativeScrollbar]'
                },] }
    ];
    HideNativeScrollbar.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: NativeScrollbarSizeFactory }
    ]; };

    var NgAttr = /** @class */ (function () {
        function NgAttr(el) {
            this.el = el;
        }
        Object.defineProperty(NgAttr.prototype, "ngAttr", {
            set: function (attrs) {
                var e_1, _a;
                try {
                    for (var _b = __values(Object.entries(attrs)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                        this.el.nativeElement.setAttribute(key, value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            },
            enumerable: false,
            configurable: true
        });
        return NgAttr;
    }());
    NgAttr.decorators = [
        { type: i0.Directive, args: [{ selector: '[ngAttr]' },] }
    ];
    NgAttr.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    NgAttr.propDecorators = {
        ngAttr: [{ type: i0.Input }]
    };

    var ResizeSensor = /** @class */ (function () {
        function ResizeSensor(zone, platform, scrollbar) {
            this.zone = zone;
            this.platform = platform;
            this.scrollbar = scrollbar;
            this._disabled = false;
            this._currentSubscription = null;
            this.event = new i0.EventEmitter();
            if (!scrollbar) {
                throw new Error('[NgScrollbar Resize Sensor Directive]: Host element must be an NgScrollbar component.');
            }
        }
        Object.defineProperty(ResizeSensor.prototype, "debounce", {
            /** Debounce interval for emitting the changes. */
            get: function () {
                return this._debounce;
            },
            set: function (value) {
                this._debounce = coercion.coerceNumberProperty(value);
                this._subscribe();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ResizeSensor.prototype, "disabled", {
            /** Whether ResizeObserver is disabled. */
            get: function () {
                return this._disabled;
            },
            set: function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                this._disabled ? this._unsubscribe() : this._subscribe();
            },
            enumerable: false,
            configurable: true
        });
        ResizeSensor.prototype.ngAfterContentInit = function () {
            if (!this._currentSubscription && !this._disabled) {
                this._subscribe();
            }
        };
        ResizeSensor.prototype.ngOnDestroy = function () {
            this._unsubscribe();
        };
        ResizeSensor.prototype._subscribe = function () {
            var _this = this;
            this._unsubscribe();
            if (this.platform.isBrowser) {
                var stream_1 = new rxjs.Observable(function (observer) {
                    _this._resizeObserver = new ResizeObserver(function (e) { return observer.next(e); });
                    _this._resizeObserver.observe(_this.scrollbar.viewport.nativeElement);
                    if (_this.scrollbar.viewport.contentWrapperElement) {
                        _this._resizeObserver.observe(_this.scrollbar.viewport.contentWrapperElement);
                    }
                });
                this.zone.runOutsideAngular(function () {
                    _this._currentSubscription = (_this._debounce ? stream_1.pipe(operators.debounceTime(_this._debounce)) : stream_1).subscribe(_this.event);
                });
            }
        };
        ResizeSensor.prototype._unsubscribe = function () {
            var _a, _b;
            (_a = this._resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
            (_b = this._currentSubscription) === null || _b === void 0 ? void 0 : _b.unsubscribe();
        };
        return ResizeSensor;
    }());
    ResizeSensor.decorators = [
        { type: i0.Directive, args: [{ selector: '[resizeSensor]' },] }
    ];
    ResizeSensor.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: i3.Platform },
        { type: NgScrollbar }
    ]; };
    ResizeSensor.propDecorators = {
        debounce: [{ type: i0.Input, args: ['sensorDebounce',] }],
        disabled: [{ type: i0.Input, args: ['sensorDisabled',] }],
        event: [{ type: i0.Output, args: ['resizeSensor',] }]
    };

    // @dynamic
    var TrackAdapter = /** @class */ (function () {
        function TrackAdapter(cmp, trackElement, document) {
            this.cmp = cmp;
            this.trackElement = trackElement;
            this.document = document;
        }
        Object.defineProperty(TrackAdapter.prototype, "clicked", {
            // Stream that emits when the track element is clicked
            get: function () {
                var mouseDown = rxjs.fromEvent(this.trackElement, 'mousedown', { passive: true }).pipe(stopPropagation(), preventSelection(this.document));
                var mouseup = rxjs.fromEvent(this.document, 'mouseup', { passive: true }).pipe(stopPropagation(), enableSelection(this.document), operators.switchMap(function () { return rxjs.EMPTY; }));
                return rxjs.merge(mouseDown, mouseup);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TrackAdapter.prototype, "clientRect", {
            // Get track client rect
            get: function () {
                return this.trackElement.getBoundingClientRect();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Stream that emits when scrollbar track is clicked
         */
        TrackAdapter.prototype.onTrackClicked = function (e, thumbSize, scrollSize) {
            var _this = this;
            return rxjs.of(e).pipe(operators.pluck(this.pageProperty), 
            // Calculate scrollTo position
            operators.map(function (pageOffset) {
                var clickOffset = pageOffset - _this.offset;
                var offset = clickOffset - (thumbSize / 2);
                var ratio = offset / _this.size;
                return ratio * scrollSize;
            }), 
            // Smooth scroll to position
            operators.tap(function (value) {
                _this.cmp.scrollTo(Object.assign(Object.assign({}, _this.mapToScrollToOption(value)), { duration: coercion.coerceNumberProperty(_this.cmp.trackClickScrollDuration) }));
            }));
        };
        return TrackAdapter;
    }());
    TrackAdapter.decorators = [
        { type: i0.Directive }
    ];
    TrackAdapter.ctorParameters = function () { return [
        { type: NgScrollbar },
        { type: HTMLElement },
        { type: undefined }
    ]; };

    // @dynamic
    var ThumbAdapter = /** @class */ (function () {
        function ThumbAdapter(cmp, track, thumbElement, document) {
            this.cmp = cmp;
            this.track = track;
            this.thumbElement = thumbElement;
            this.document = document;
            // Stream that emits dragging state
            this._dragging = new rxjs.Subject();
            this.dragging = this._dragging.pipe(operators.distinctUntilChanged());
        }
        Object.defineProperty(ThumbAdapter.prototype, "trackMax", {
            get: function () {
                return this.track.size - this.size;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbAdapter.prototype, "clientRect", {
            // Get thumb client rect
            get: function () {
                return this.thumbElement.getBoundingClientRect();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbAdapter.prototype, "clicked", {
            // Stream that emits when scrollbar thumb is clicked
            get: function () {
                return rxjs.fromEvent(this.thumbElement, 'mousedown', { passive: true }).pipe(stopPropagation());
            },
            enumerable: false,
            configurable: true
        });
        // Calculate and update thumb position and size
        ThumbAdapter.prototype.update = function () {
            var _this = this;
            var size = calculateThumbSize(this.track.size, this.viewportScrollSize, this.cmp.minThumbSize);
            var position = calculateThumbPosition(this.viewportScrollOffset, this.viewportScrollMax, this.trackMax);
            rxjs.animationFrameScheduler.schedule(function () { return _this.updateStyles(_this.handleDirection(position, _this.trackMax), size); });
        };
        /**
         * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged
         * This function is called by thumb drag event using viewport or scrollbar pointer events
         */
        ThumbAdapter.prototype.dragged = function (event) {
            var _this = this;
            var trackMaxStart;
            var scrollMaxStart;
            var dragStart = rxjs.of(event).pipe(preventSelection(this.document), operators.tap(function () {
                // Capture scrollMax and trackMax once
                trackMaxStart = _this.trackMax;
                scrollMaxStart = _this.viewportScrollMax;
                _this.setDragging(true);
            }));
            var dragging = rxjs.fromEvent(this.document, 'mousemove', { capture: true, passive: true }).pipe(stopPropagation());
            var dragEnd = rxjs.fromEvent(this.document, 'mouseup', { capture: true }).pipe(stopPropagation(), enableSelection(this.document), operators.tap(function () { return _this.setDragging(false); }));
            return dragStart.pipe(operators.pluck(this.pageProperty), operators.map(function (pageOffset) { return pageOffset - _this.dragStartOffset; }), operators.mergeMap(function (mouseDownOffset) { return dragging.pipe(operators.pluck(_this.clientProperty), 
            // Calculate how far the pointer is from the top/left of the scrollbar (minus the dragOffset).
            operators.map(function (mouseOffset) { return mouseOffset - _this.track.offset; }), operators.map(function (offset) { return scrollMaxStart * (offset - mouseDownOffset) / trackMaxStart; }), operators.map(function (position) { return _this.handleDrag(position, scrollMaxStart); }), operators.tap(function (position) { return _this.scrollTo(position); }), operators.takeUntil(dragEnd)); }));
        };
        return ThumbAdapter;
    }());
    ThumbAdapter.decorators = [
        { type: i0.Directive }
    ];
    ThumbAdapter.ctorParameters = function () { return [
        { type: NgScrollbar },
        { type: TrackAdapter },
        { type: HTMLElement },
        { type: undefined }
    ]; };
    ThumbAdapter.propDecorators = {
        dragging: [{ type: i0.Output }]
    };
    /**
     * Calculate scrollbar thumb size
     */
    function calculateThumbSize(trackSize, contentSize, minThumbSize) {
        var scrollbarRatio = trackSize / contentSize;
        var thumbSize = scrollbarRatio * trackSize;
        return Math.max(~~thumbSize, minThumbSize);
    }
    /**
     * Calculate scrollbar thumb position
     */
    function calculateThumbPosition(scrollPosition, scrollMax, trackMax) {
        return scrollPosition * trackMax / scrollMax;
    }

    var TrackXDirective = /** @class */ (function (_super) {
        __extends(TrackXDirective, _super);
        function TrackXDirective(cmp, trackElement, document) {
            var _this = _super.call(this, cmp, trackElement.nativeElement, document) || this;
            _this.cmp = cmp;
            _this.document = document;
            return _this;
        }
        Object.defineProperty(TrackXDirective.prototype, "pageProperty", {
            get: function () {
                return 'pageX';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TrackXDirective.prototype, "offset", {
            get: function () {
                return this.clientRect.left;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TrackXDirective.prototype, "size", {
            get: function () {
                return this.trackElement.clientWidth;
            },
            enumerable: false,
            configurable: true
        });
        TrackXDirective.prototype.mapToScrollToOption = function (value) {
            return { left: value };
        };
        return TrackXDirective;
    }(TrackAdapter));
    TrackXDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[scrollbarTrackX]' },] }
    ];
    TrackXDirective.ctorParameters = function () { return [
        { type: NgScrollbar },
        { type: i0.ElementRef },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] }
    ]; };
    var TrackYDirective = /** @class */ (function (_super) {
        __extends(TrackYDirective, _super);
        function TrackYDirective(cmp, trackElement, document) {
            var _this = _super.call(this, cmp, trackElement.nativeElement, document) || this;
            _this.cmp = cmp;
            _this.document = document;
            return _this;
        }
        Object.defineProperty(TrackYDirective.prototype, "pageProperty", {
            get: function () {
                return 'pageY';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TrackYDirective.prototype, "offset", {
            get: function () {
                return this.clientRect.top;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TrackYDirective.prototype, "size", {
            get: function () {
                return this.trackElement.clientHeight;
            },
            enumerable: false,
            configurable: true
        });
        TrackYDirective.prototype.mapToScrollToOption = function (value) {
            return { top: value };
        };
        return TrackYDirective;
    }(TrackAdapter));
    TrackYDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[scrollbarTrackY]' },] }
    ];
    TrackYDirective.ctorParameters = function () { return [
        { type: NgScrollbar },
        { type: i0.ElementRef },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] }
    ]; };

    var ThumbXDirective = /** @class */ (function (_super) {
        __extends(ThumbXDirective, _super);
        function ThumbXDirective(cmp, track, element, document, dir) {
            var _this = _super.call(this, cmp, track, element.nativeElement, document) || this;
            _this.cmp = cmp;
            _this.track = track;
            _this.element = element;
            _this.document = document;
            _this.dir = dir;
            return _this;
        }
        Object.defineProperty(ThumbXDirective.prototype, "clientProperty", {
            get: function () {
                return 'clientX';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbXDirective.prototype, "pageProperty", {
            get: function () {
                return 'pageX';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbXDirective.prototype, "viewportScrollSize", {
            get: function () {
                return this.cmp.viewport.scrollWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbXDirective.prototype, "viewportScrollOffset", {
            get: function () {
                return this.cmp.viewport.scrollLeft;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbXDirective.prototype, "viewportScrollMax", {
            get: function () {
                return this.cmp.viewport.scrollMaxX;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbXDirective.prototype, "dragStartOffset", {
            get: function () {
                return this.clientRect.left + this.document.defaultView.pageXOffset || 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbXDirective.prototype, "size", {
            get: function () {
                return this.thumbElement.clientWidth;
            },
            enumerable: false,
            configurable: true
        });
        ThumbXDirective.prototype.updateStyles = function (position, size) {
            this.thumbElement.style.width = size + "px";
            this.thumbElement.style.transform = "translate3d(" + position + "px, 0, 0)";
        };
        ThumbXDirective.prototype.handleDrag = function (position, scrollMax) {
            if (this.dir.value === 'rtl') {
                if (this.cmp.manager.rtlScrollAxisType === 1 /* NEGATED */) {
                    return position - scrollMax;
                }
                if (this.cmp.manager.rtlScrollAxisType === 2 /* INVERTED */) {
                    return scrollMax - position;
                }
                // Keeping this as a memo
                // if (this.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {
                //   return position;
                // }
            }
            return position;
        };
        ThumbXDirective.prototype.handleDirection = function (position, trackMax) {
            if (this.dir.value === 'rtl') {
                if (this.cmp.manager.rtlScrollAxisType === 2 /* INVERTED */) {
                    return -position;
                }
                if (this.cmp.manager.rtlScrollAxisType === 0 /* NORMAL */) {
                    return position - trackMax;
                }
                // Keeping this as a memo
                // if (this.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                //   return position;
                // }
            }
            return position;
        };
        ThumbXDirective.prototype.setDragging = function (value) {
            this.cmp.setDragging({ horizontalDragging: value });
        };
        ThumbXDirective.prototype.scrollTo = function (position) {
            this.cmp.viewport.scrollXTo(position);
        };
        return ThumbXDirective;
    }(ThumbAdapter));
    ThumbXDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[scrollbarThumbX]' },] }
    ];
    ThumbXDirective.ctorParameters = function () { return [
        { type: NgScrollbar },
        { type: TrackXDirective },
        { type: i0.ElementRef },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] },
        { type: bidi.Directionality }
    ]; };
    var ThumbYDirective = /** @class */ (function (_super) {
        __extends(ThumbYDirective, _super);
        function ThumbYDirective(cmp, track, element, document) {
            var _this = _super.call(this, cmp, track, element.nativeElement, document) || this;
            _this.cmp = cmp;
            _this.track = track;
            _this.element = element;
            _this.document = document;
            return _this;
        }
        Object.defineProperty(ThumbYDirective.prototype, "pageProperty", {
            get: function () {
                return 'pageY';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbYDirective.prototype, "viewportScrollSize", {
            get: function () {
                return this.cmp.viewport.scrollHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbYDirective.prototype, "viewportScrollOffset", {
            get: function () {
                return this.cmp.viewport.scrollTop;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbYDirective.prototype, "viewportScrollMax", {
            get: function () {
                return this.cmp.viewport.scrollMaxY;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbYDirective.prototype, "clientProperty", {
            get: function () {
                return 'clientY';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbYDirective.prototype, "dragStartOffset", {
            get: function () {
                return this.clientRect.top + this.document.defaultView.pageYOffset || 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThumbYDirective.prototype, "size", {
            get: function () {
                return this.thumbElement.clientHeight;
            },
            enumerable: false,
            configurable: true
        });
        ThumbYDirective.prototype.updateStyles = function (position, size) {
            this.thumbElement.style.height = size + "px";
            this.thumbElement.style.transform = "translate3d(0px, " + position + "px, 0)";
        };
        ThumbYDirective.prototype.handleDrag = function (position) {
            return position;
        };
        ThumbYDirective.prototype.handleDirection = function (position) {
            return position;
        };
        ThumbYDirective.prototype.setDragging = function (value) {
            this.cmp.setDragging({ verticalDragging: value });
        };
        ThumbYDirective.prototype.scrollTo = function (position) {
            this.cmp.viewport.scrollYTo(position);
        };
        return ThumbYDirective;
    }(ThumbAdapter));
    ThumbYDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[scrollbarThumbY]' },] }
    ];
    ThumbYDirective.ctorParameters = function () { return [
        { type: NgScrollbar },
        { type: TrackYDirective },
        { type: i0.ElementRef },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] }
    ]; };

    // @dynamic
    var Scrollbar = /** @class */ (function () {
        function Scrollbar(el, cmp, platform, document, zone) {
            this.el = el;
            this.cmp = cmp;
            this.platform = platform;
            this.document = document;
            this.zone = zone;
            // Stream that emits to unsubscribe from all streams
            this.destroyed = new rxjs.Subject();
        }
        /**
         * Activate scrollbar pointer events
         */
        Scrollbar.prototype.activatePointerEvents = function () {
            var _this = this;
            // Stream that emits when scrollbar thumb is dragged
            var thumbDragEvent;
            // Stream that emits when scrollbar track is clicked
            var trackClickEvent;
            // Stream that emits when scrollbar track is hovered
            var trackHoveredEvent;
            // Set the method used for the pointer events option
            if (this.cmp.pointerEventsMethod === 'viewport') {
                // Pointer events using the viewport
                this.viewportTrackClicked = new rxjs.Subject();
                this.viewportThumbClicked = new rxjs.Subject();
                // Activate the pointer events of the viewport directive
                this.cmp.viewport.activatePointerEvents(this.cmp.viewportPropagateMouseMove, this.destroyed);
                // Set streams
                thumbDragEvent = this.viewportThumbClicked;
                trackClickEvent = this.viewportTrackClicked;
                trackHoveredEvent = this.cmp.viewport.hovered.pipe(
                // Check if track is hovered
                operators.map(function (e) { return isWithinBounds(e, _this.el.getBoundingClientRect()); }), operators.distinctUntilChanged(), 
                // Enable / disable text selection
                operators.tap(function (hovered) { return _this.document.onselectstart = hovered ? function () { return false; } : null; }));
                this.cmp.viewport.clicked.pipe(operators.tap(function (e) {
                    if (e) {
                        if (isWithinBounds(e, _this.thumb.clientRect)) {
                            _this.viewportThumbClicked.next(e);
                        }
                        else if (isWithinBounds(e, _this.track.clientRect)) {
                            _this.cmp.setClicked(true);
                            _this.viewportTrackClicked.next(e);
                        }
                    }
                    else {
                        _this.cmp.setClicked(false);
                    }
                }), operators.takeUntil(this.destroyed)).subscribe();
            }
            else {
                // Pointer events method is using 'scrollbar'
                thumbDragEvent = this.thumb.clicked;
                trackClickEvent = this.track.clicked;
                trackHoveredEvent = this.hovered;
            }
            return rxjs.merge(
            // Activate scrollbar hovered event
            trackHoveredEvent.pipe(operators.tap(function (e) { return _this.setHovered(e); })), 
            // Activate scrollbar thumb drag event
            thumbDragEvent.pipe(operators.switchMap(function (e) { return _this.thumb.dragged(e); })), 
            // Activate scrollbar track click event
            trackClickEvent.pipe(operators.switchMap(function (e) { return _this.track.onTrackClicked(e, _this.thumb.size, _this.viewportScrollSize); })));
        };
        Object.defineProperty(Scrollbar.prototype, "hovered", {
            // Stream that emits when the track element is hovered
            get: function () {
                var mouseEnter = rxjs.fromEvent(this.el, 'mouseenter', { passive: true }).pipe(stopPropagation(), operators.map(function () { return true; }));
                var mouseLeave = rxjs.fromEvent(this.el, 'mouseleave', { passive: true }).pipe(stopPropagation(), operators.map(function () { return false; }));
                return rxjs.merge(mouseEnter, mouseLeave);
            },
            enumerable: false,
            configurable: true
        });
        Scrollbar.prototype.ngOnInit = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                // Activate pointer events on Desktop only
                if (!(_this.platform.IOS || _this.platform.ANDROID) && !_this.cmp.pointerEventsDisabled) {
                    _this.activatePointerEvents().pipe(operators.takeUntil(_this.destroyed)).subscribe();
                }
                // Update scrollbar thumb when viewport is scrolled and when scrollbar component is updated
                rxjs.merge(_this.cmp.scrolled, _this.cmp.updated).pipe(operators.tap(function () { var _a; return (_a = _this.thumb) === null || _a === void 0 ? void 0 : _a.update(); }), operators.takeUntil(_this.destroyed)).subscribe();
            });
        };
        Scrollbar.prototype.ngOnDestroy = function () {
            this.destroyed.next();
            this.destroyed.complete();
            // Clean up viewport streams if used
            if (this.viewportThumbClicked && this.viewportTrackClicked) {
                this.viewportTrackClicked.complete();
                this.viewportThumbClicked.complete();
            }
        };
        return Scrollbar;
    }());
    Scrollbar.decorators = [
        { type: i0.Directive }
    ];
    Scrollbar.ctorParameters = function () { return [
        { type: HTMLElement },
        { type: NgScrollbar },
        { type: i3.Platform },
        { type: undefined },
        { type: i0.NgZone }
    ]; };

    var ScrollbarY = /** @class */ (function (_super) {
        __extends(ScrollbarY, _super);
        function ScrollbarY(el, cmp, platform, document, zone) {
            var _this = _super.call(this, el.nativeElement, cmp, platform, document, zone) || this;
            _this.cmp = cmp;
            _this.platform = platform;
            _this.document = document;
            _this.zone = zone;
            return _this;
        }
        Object.defineProperty(ScrollbarY.prototype, "viewportScrollSize", {
            get: function () {
                return this.cmp.viewport.scrollHeight;
            },
            enumerable: false,
            configurable: true
        });
        ScrollbarY.prototype.setHovered = function (value) {
            this.cmp.setHovered({ verticalHovered: value });
        };
        return ScrollbarY;
    }(Scrollbar));
    ScrollbarY.decorators = [
        { type: i0.Component, args: [{
                    selector: 'scrollbar-y',
                    host: { '[class.scrollbar-control]': 'true' },
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    template: "\n    <div scrollbarTrackY class=\"ng-scrollbar-track {{cmp.trackClass}}\">\n      <div scrollbarThumbY class=\"ng-scrollbar-thumb {{cmp.thumbClass}}\"></div>\n    </div>\n  ",
                    styles: ["::ng-deep .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control{width:var(--vertical-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track{width:var(--vertical-scrollbar-size);height:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{height:0;width:100%}::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[verticalHovered=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[deactivated=false]>scrollbar-y.scrollbar-control{top:0;bottom:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=ltr]>scrollbar-y.scrollbar-control{right:0;left:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertAll]>scrollbar-y.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertY]>scrollbar-y.scrollbar-control{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=rtl]>scrollbar-y.scrollbar-control{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertAll]>scrollbar-y.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertY]>scrollbar-y.scrollbar-control{left:unset;right:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all]>scrollbar-y.scrollbar-control[fit=true]{bottom:var(--scrollbar-total-size);top:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertAll]>scrollbar-y.scrollbar-control[fit=true],::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertX]>scrollbar-y.scrollbar-control[fit=true]{top:var(--scrollbar-total-size);bottom:0}"]
                },] }
    ];
    ScrollbarY.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: NgScrollbar },
        { type: i3.Platform },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] },
        { type: i0.NgZone }
    ]; };
    ScrollbarY.propDecorators = {
        track: [{ type: i0.ViewChild, args: [TrackYDirective, { static: true },] }],
        thumb: [{ type: i0.ViewChild, args: [ThumbYDirective, { static: true },] }]
    };
    var ScrollbarX = /** @class */ (function (_super) {
        __extends(ScrollbarX, _super);
        function ScrollbarX(el, cmp, platform, document, zone) {
            var _this = _super.call(this, el.nativeElement, cmp, platform, document, zone) || this;
            _this.cmp = cmp;
            _this.platform = platform;
            _this.document = document;
            _this.zone = zone;
            return _this;
        }
        Object.defineProperty(ScrollbarX.prototype, "viewportScrollSize", {
            get: function () {
                return this.cmp.viewport.scrollWidth;
            },
            enumerable: false,
            configurable: true
        });
        ScrollbarX.prototype.setHovered = function (value) {
            this.cmp.setHovered({ horizontalHovered: value });
        };
        return ScrollbarX;
    }(Scrollbar));
    ScrollbarX.decorators = [
        { type: i0.Component, args: [{
                    selector: 'scrollbar-x',
                    host: { '[class.scrollbar-control]': 'true' },
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    template: "\n    <div scrollbarTrackX class=\"ng-scrollbar-track {{cmp.trackClass}}\">\n      <div scrollbarThumbX class=\"ng-scrollbar-thumb {{cmp.thumbClass}}\"></div>\n    </div>\n  ",
                    styles: ["::ng-deep .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control{height:var(--horizontal-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track{height:var(--horizontal-scrollbar-size);width:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{width:0;height:100%}::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[horizontalHovered=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[position=invertAll]>scrollbar-x.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[position=invertX]>scrollbar-x.scrollbar-control{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false]>scrollbar-x.scrollbar-control{left:0;right:0;bottom:0;top:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][position=invertAll]>scrollbar-x.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[deactivated=false][position=invertX]>scrollbar-x.scrollbar-control{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr]>scrollbar-x.scrollbar-control[fit=true]{right:var(--scrollbar-total-size);left:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertAll]>scrollbar-x.scrollbar-control[fit=true],::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertY]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertAll]>scrollbar-x.scrollbar-control[fit=true],::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertY]>scrollbar-x.scrollbar-control[fit=true]{right:var(--scrollbar-total-size);left:0}"]
                },] }
    ];
    ScrollbarX.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: NgScrollbar },
        { type: i3.Platform },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] },
        { type: i0.NgZone }
    ]; };
    ScrollbarX.propDecorators = {
        track: [{ type: i0.ViewChild, args: [TrackXDirective, { static: true },] }],
        thumb: [{ type: i0.ViewChild, args: [ThumbXDirective, { static: true },] }]
    };

    var NgScrollbarModule = /** @class */ (function () {
        function NgScrollbarModule() {
        }
        NgScrollbarModule.withConfig = function (options) {
            return {
                ngModule: NgScrollbarModule,
                providers: [
                    { provide: NG_SCROLLBAR_OPTIONS, useValue: options }
                ]
            };
        };
        return NgScrollbarModule;
    }());
    NgScrollbarModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1.CommonModule,
                        bidi.BidiModule,
                        portal.PortalModule,
                        i3.PlatformModule,
                        smoothScroll.SmoothScrollModule
                    ],
                    declarations: [
                        NgScrollbar,
                        ScrollViewport,
                        HideNativeScrollbar,
                        NgAttr,
                        ResizeSensor,
                        ThumbYDirective,
                        ThumbXDirective,
                        TrackXDirective,
                        TrackYDirective,
                        ScrollbarY,
                        ScrollbarX
                    ],
                    exports: [
                        NgScrollbar,
                        ScrollViewport
                    ]
                },] }
    ];

    /*
     * Public API Surface of ngx-scrollbar
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.NG_SCROLLBAR_OPTIONS = NG_SCROLLBAR_OPTIONS;
    exports.NgScrollbar = NgScrollbar;
    exports.NgScrollbarModule = NgScrollbarModule;
    exports.ScrollViewport = ScrollViewport;
    exports.ScrollbarManager = ScrollbarManager;
    exports.ɵa = HideNativeScrollbar;
    exports.ɵb = NativeScrollbarSizeFactory;
    exports.ɵc = NgAttr;
    exports.ɵd = ResizeSensor;
    exports.ɵe = ThumbXDirective;
    exports.ɵf = ThumbYDirective;
    exports.ɵg = ThumbAdapter;
    exports.ɵh = TrackAdapter;
    exports.ɵi = TrackXDirective;
    exports.ɵj = TrackYDirective;
    exports.ɵk = ScrollbarY;
    exports.ɵl = ScrollbarX;
    exports.ɵm = Scrollbar;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-scrollbar.umd.js.map
