{"version":3,"file":"ngx-scrollbar-smooth-scroll.js","sources":["../../../projects/ngx-scrollbar/smooth-scroll/src/smooth-scroll.model.ts","../../../projects/ngx-scrollbar/smooth-scroll/src/smooth-scroll-manager.ts","../../../projects/ngx-scrollbar/smooth-scroll/src/smooth-scroll.ts","../../../projects/ngx-scrollbar/smooth-scroll/src/smooth-scroll.module.ts","../../../projects/ngx-scrollbar/smooth-scroll/src/ngx-scrollbar-smooth-scroll.ts"],"names":[],"mappings":"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","sourcesContent":["import { ElementRef, InjectionToken } from '@angular/core';\nimport { _Left, _Top, _XAxis, _YAxis } from '@angular/cdk/scrolling';\n\nexport const SMOOTH_SCROLL_OPTIONS = new InjectionToken<SmoothScrollOptions>('SMOOTH_SCROLL_OPTIONS');\n\nexport type SmoothScrollElement = HTMLElement | ElementRef<HTMLElement> | string;\n\nexport type SmoothScrollToOptions = _XAxis & _YAxis & SmoothScrollOptions;\n\nexport type SmoothScrollToElementOptions = _Top & _Left & SmoothScrollOptions;\n\nexport interface SmoothScrollOptions {\n  duration?: number;\n  easing?: BezierEasingOptions;\n}\n\nexport interface SmoothScrollStep {\n  scrollable: HTMLElement;\n  startTime: number;\n  startX: number;\n  startY: number;\n  x: number;\n  y: number;\n  duration: number;\n  easing: (k: number) => number;\n  currentX?: number;\n  currentY?: number;\n}\n\nexport interface BezierEasingOptions {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n}\n","import { ElementRef, Inject, Injectable, PLATFORM_ID, Optional } from '@angular/core';\nimport { DOCUMENT, isPlatformBrowser } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { getRtlScrollAxisType, RtlScrollAxisType } from '@angular/cdk/platform';\nimport { _Bottom, _Left, _Right, _Top, _Without } from '@angular/cdk/scrolling';\nimport { fromEvent, merge, of, Observable, Subject, Subscriber, animationFrameScheduler } from 'rxjs';\nimport { expand, finalize, take, takeUntil, takeWhile } from 'rxjs/operators';\nimport BezierEasing from 'bezier-easing';\nimport {\n  SMOOTH_SCROLL_OPTIONS,\n  SmoothScrollElement,\n  SmoothScrollStep,\n  SmoothScrollToElementOptions,\n  SmoothScrollToOptions\n} from './smooth-scroll.model';\n\n// @dynamic\n@Injectable({\n  providedIn: 'root'\n})\nexport class SmoothScrollManager {\n\n  // Default options\n  private readonly _defaultOptions: SmoothScrollToOptions;\n\n  // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\n  // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\n  // Purpose: If user called a scroll function again on the same element before the scrolls completes,\n  // it cancels the ongoing scroll and starts a new one\n  private _onGoingScrolls = new Map<HTMLElement, Subject<void>>();\n\n  private get _w(): any {\n    return this._document.defaultView;\n  }\n\n  /**\n   * Timing method\n   */\n  private get _now() {\n    return this._w.performance && this._w.performance.now\n      ? this._w.performance.now.bind(this._w.performance)\n      : Date.now;\n  }\n\n  constructor(@Inject(DOCUMENT) private _document: any,\n              @Inject(PLATFORM_ID) private _platform: object,\n              @Optional() @Inject(SMOOTH_SCROLL_OPTIONS) customDefaultOptions: SmoothScrollToOptions) {\n    this._defaultOptions = {\n      duration: 468,\n      easing: {\n        x1: 0.42,\n        y1: 0,\n        x2: 0.58,\n        y2: 1\n      },\n      ...customDefaultOptions,\n    };\n  }\n\n  /**\n   * changes scroll position inside an element\n   */\n  private _scrollElement(el: HTMLElement, x: number, y: number): void {\n    el.scrollLeft = x;\n    el.scrollTop = y;\n  }\n\n  /**\n   * Handles a given parameter of type HTMLElement, ElementRef or selector\n   */\n  private _getElement(el: HTMLElement | ElementRef | string, parent?: HTMLElement): HTMLElement {\n    if (typeof el === 'string') {\n      return (parent || this._document).querySelector(el);\n    }\n    return coerceElement<HTMLElement>(el);\n  }\n\n  /**\n   * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\n   */\n  private _initSmoothScroll(el: HTMLElement): Subject<void> {\n    if (this._onGoingScrolls.has(el)) {\n      this._onGoingScrolls.get(el)!.next();\n    }\n    return this._onGoingScrolls.set(el, new Subject<void>())!.get(el)!;\n  }\n\n  /**\n   * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\n   */\n  private _isFinished(context: SmoothScrollStep, destroyed: Subject<void>, resolve: () => void): boolean {\n    if (context.currentX !== context.x || context.currentY !== context.y) {\n      return true;\n    }\n    destroyed.next();\n    resolve();\n    return false;\n  }\n\n  /**\n   * Terminates an ongoing smooth scroll\n   */\n  private _interrupted(el: HTMLElement, destroyed: Subject<void>): Observable<any> {\n    return merge(\n      fromEvent(el, 'wheel', { passive: true, capture: true }),\n      fromEvent(el, 'touchmove', { passive: true, capture: true }),\n      destroyed\n    ).pipe(take(1));\n  }\n\n  /**\n   * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\n   */\n  private _destroy(el: HTMLElement, destroyed: Subject<void>): void {\n    destroyed.complete();\n    this._onGoingScrolls.delete(el);\n  }\n\n  /**\n   * A function called recursively that, given a context, steps through scrolling\n   */\n  private _step(context: SmoothScrollStep): Observable<SmoothScrollStep> {\n    return new Observable((subscriber: Subscriber<SmoothScrollStep>) => {\n      let elapsed = (this._now() - context.startTime) / context.duration;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      const value = context.easing(elapsed);\n\n      context.currentX = context.startX + (context.x - context.startX) * value;\n      context.currentY = context.startY + (context.y - context.startY) * value;\n\n      this._scrollElement(context.scrollable, context.currentX, context.currentY);\n      // Proceed to the step\n      animationFrameScheduler.schedule(() => subscriber.next(context));\n    });\n  }\n\n  private _applyScrollToOptions(el: HTMLElement, options: SmoothScrollToOptions): Promise<void> {\n    if (!options.duration!) {\n      this._scrollElement(el, options!.left!, options!.top!);\n      return Promise.resolve();\n    }\n\n    // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\n    const destroyed: Subject<void> = this._initSmoothScroll(el);\n\n    const context: SmoothScrollStep = {\n      scrollable: el,\n      startTime: this._now(),\n      startX: el.scrollLeft,\n      startY: el.scrollTop,\n      x: options.left == null ? el.scrollLeft : ~~options.left,\n      y: options.top == null ? el.scrollTop : ~~options.top,\n      duration: options.duration!,\n      easing: BezierEasing(options.easing!.x1!, options.easing!.y1!, options.easing!.x2!, options.easing!.y2!)\n    };\n\n    return new Promise(resolve => {\n      // Scroll each step recursively\n      of(null).pipe(\n        expand(() => this._step(context).pipe(\n          takeWhile((currContext: SmoothScrollStep) => this._isFinished(currContext, destroyed, resolve))\n        )),\n        takeUntil(this._interrupted(el, destroyed)),\n        finalize(() => this._destroy(el, destroyed))\n      ).subscribe();\n    });\n  }\n\n\n  /**\n   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n   * left and right always refer to the left and right side of the scrolling container irrespective\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n   * in an RTL context.\n   * @param scrollable element\n   * @param customOptions specified the offsets to scroll to.\n   */\n  scrollTo(scrollable: SmoothScrollElement, customOptions: SmoothScrollToOptions): Promise<void> {\n    if (isPlatformBrowser(this._platform)) {\n      const el = this._getElement(scrollable);\n      const isRtl = getComputedStyle(el).direction === 'rtl';\n      const rtlScrollAxisType = getRtlScrollAxisType();\n\n      const options: SmoothScrollToOptions = {\n        ...(this._defaultOptions as _Without<_Bottom & _Top>),\n        ...customOptions,\n        ...({\n          // Rewrite start & end offsets as right or left offsets.\n          left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,\n          right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right\n        } as _Without<_Bottom & _Top>)\n      };\n\n      // Rewrite the bottom offset as a top offset.\n      if (options.bottom != null) {\n        (options as _Without<_Bottom> & _Top).top = el.scrollHeight - el.clientHeight - options.bottom;\n      }\n\n      // Rewrite the right offset as a left offset.\n      if (isRtl && rtlScrollAxisType !== RtlScrollAxisType.NORMAL) {\n        if (options.left != null) {\n          (options as _Without<_Left> & _Right).right = el.scrollWidth - el.clientWidth - options.left;\n        }\n\n        if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {\n          options.left = options.right;\n        } else if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {\n          options.left = options.right ? -options.right : options.right;\n        }\n      } else {\n        if (options.right != null) {\n          (options as _Without<_Right> & _Left).left = el.scrollWidth - el.clientWidth - options.right;\n        }\n      }\n      return this._applyScrollToOptions(el, options);\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Scroll to element by reference or selector\n   */\n  scrollToElement(scrollable: SmoothScrollElement, target: SmoothScrollElement, customOptions: SmoothScrollToElementOptions = {}): Promise<void> {\n    const scrollableEl = this._getElement(scrollable);\n    const targetEl = this._getElement(target, scrollableEl);\n    const options: SmoothScrollToOptions = {\n      ...customOptions,\n      ...{\n        left: targetEl.offsetLeft + (customOptions.left || 0),\n        top: targetEl.offsetTop + (customOptions.top || 0)\n      }\n    };\n    return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();\n  }\n}\n","import { Directive, ElementRef } from '@angular/core';\nimport { SmoothScrollManager } from './smooth-scroll-manager';\nimport { SmoothScrollElement, SmoothScrollToElementOptions, SmoothScrollToOptions } from './smooth-scroll.model';\n\n@Directive({\n  selector: '[smoothScroll], [smooth-scroll]',\n  exportAs: 'smoothScroll'\n})\nexport class SmoothScroll {\n\n  constructor(private element: ElementRef, private smoothScroll: SmoothScrollManager) {\n  }\n\n  scrollTo(options: SmoothScrollToOptions): Promise<void> | undefined {\n    return this.smoothScroll.scrollTo(this.element, options);\n  }\n\n  scrollToElement(target: SmoothScrollElement, options: SmoothScrollToElementOptions): Promise<void> | undefined {\n    return this.smoothScroll.scrollToElement(this.element, target, options);\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { SmoothScroll } from './smooth-scroll';\n\n@NgModule({\n  declarations: [SmoothScroll],\n  exports: [SmoothScroll]\n})\nexport class SmoothScrollModule {\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"]}