import { Directive } from '@angular/core';
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { EMPTY, fromEvent, merge, of } from 'rxjs';
import { map, pluck, switchMap, tap } from 'rxjs/operators';
import { preventSelection, enableSelection, stopPropagation } from '../common';
import { NgScrollbar } from '../../ng-scrollbar';
// @dynamic
export class TrackAdapter {
    constructor(cmp, trackElement, document) {
        this.cmp = cmp;
        this.trackElement = trackElement;
        this.document = document;
    }
    // Stream that emits when the track element is clicked
    get clicked() {
        const mouseDown = fromEvent(this.trackElement, 'mousedown', { passive: true }).pipe(stopPropagation(), preventSelection(this.document));
        const mouseup = fromEvent(this.document, 'mouseup', { passive: true }).pipe(stopPropagation(), enableSelection(this.document), switchMap(() => EMPTY));
        return merge(mouseDown, mouseup);
    }
    // Get track client rect
    get clientRect() {
        return this.trackElement.getBoundingClientRect();
    }
    /**
     * Stream that emits when scrollbar track is clicked
     */
    onTrackClicked(e, thumbSize, scrollSize) {
        return of(e).pipe(pluck(this.pageProperty), 
        // Calculate scrollTo position
        map((pageOffset) => {
            const clickOffset = pageOffset - this.offset;
            const offset = clickOffset - (thumbSize / 2);
            const ratio = offset / this.size;
            return ratio * scrollSize;
        }), 
        // Smooth scroll to position
        tap((value) => {
            this.cmp.scrollTo(Object.assign(Object.assign({}, this.mapToScrollToOption(value)), { duration: coerceNumberProperty(this.cmp.trackClickScrollDuration) }));
        }));
    }
}
TrackAdapter.decorators = [
    { type: Directive }
];
TrackAdapter.ctorParameters = () => [
    { type: NgScrollbar },
    { type: HTMLElement },
    { type: undefined }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtc2Nyb2xsYmFyL3NyYy9saWIvc2Nyb2xsYmFyL3RyYWNrL3RyYWNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUMsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDN0QsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFjLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvRCxPQUFPLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDNUQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDL0UsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRWpELFdBQVc7QUFFWCxNQUFNLE9BQWdCLFlBQVk7SUE4QmhDLFlBQWdDLEdBQWdCLEVBQ2hCLFlBQXlCLEVBQ3pCLFFBQWE7UUFGYixRQUFHLEdBQUgsR0FBRyxDQUFhO1FBQ2hCLGlCQUFZLEdBQVosWUFBWSxDQUFhO1FBQ3pCLGFBQVEsR0FBUixRQUFRLENBQUs7SUFDN0MsQ0FBQztJQS9CRCxzREFBc0Q7SUFDdEQsSUFBSSxPQUFPO1FBQ1QsTUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsV0FBVyxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUNqRixlQUFlLEVBQUUsRUFDakIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUNoQyxDQUFDO1FBQ0YsTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUN6RSxlQUFlLEVBQUUsRUFDakIsZUFBZSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFDOUIsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUN2QixDQUFDO1FBQ0YsT0FBTyxLQUFLLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFXRCx3QkFBd0I7SUFDeEIsSUFBSSxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFDbkQsQ0FBQztJQU9EOztPQUVHO0lBQ0gsY0FBYyxDQUFDLENBQU0sRUFBRSxTQUFpQixFQUFFLFVBQWtCO1FBQzFELE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDZixLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztRQUN4Qiw4QkFBOEI7UUFDOUIsR0FBRyxDQUFDLENBQUMsVUFBa0IsRUFBRSxFQUFFO1lBQ3pCLE1BQU0sV0FBVyxHQUFHLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQzdDLE1BQU0sTUFBTSxHQUFHLFdBQVcsR0FBRyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM3QyxNQUFNLEtBQUssR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztZQUNqQyxPQUFPLEtBQUssR0FBRyxVQUFVLENBQUM7UUFDNUIsQ0FBQyxDQUFDO1FBQ0YsNEJBQTRCO1FBQzVCLEdBQUcsQ0FBQyxDQUFDLEtBQWEsRUFBRSxFQUFFO1lBQ3BCLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxpQ0FDWixJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLEtBQ2xDLFFBQVEsRUFBRSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLHdCQUF3QixDQUFDLElBQ2pFLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQzs7O1lBekRGLFNBQVM7OztZQUhELFdBQVc7WUFtQzRCLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGNvZXJjZU51bWJlclByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IEVNUFRZLCBmcm9tRXZlbnQsIG1lcmdlLCBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBwbHVjaywgc3dpdGNoTWFwLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBwcmV2ZW50U2VsZWN0aW9uLCBlbmFibGVTZWxlY3Rpb24sIHN0b3BQcm9wYWdhdGlvbiB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBOZ1Njcm9sbGJhciB9IGZyb20gJy4uLy4uL25nLXNjcm9sbGJhcic7XG5cbi8vIEBkeW5hbWljXG5ARGlyZWN0aXZlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUcmFja0FkYXB0ZXIge1xuXG4gIC8vIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gdGhlIHRyYWNrIGVsZW1lbnQgaXMgY2xpY2tlZFxuICBnZXQgY2xpY2tlZCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIGNvbnN0IG1vdXNlRG93biA9IGZyb21FdmVudCh0aGlzLnRyYWNrRWxlbWVudCwgJ21vdXNlZG93bicsIHsgcGFzc2l2ZTogdHJ1ZSB9KS5waXBlKFxuICAgICAgc3RvcFByb3BhZ2F0aW9uKCksXG4gICAgICBwcmV2ZW50U2VsZWN0aW9uKHRoaXMuZG9jdW1lbnQpXG4gICAgKTtcbiAgICBjb25zdCBtb3VzZXVwID0gZnJvbUV2ZW50KHRoaXMuZG9jdW1lbnQsICdtb3VzZXVwJywgeyBwYXNzaXZlOiB0cnVlIH0pLnBpcGUoXG4gICAgICBzdG9wUHJvcGFnYXRpb24oKSxcbiAgICAgIGVuYWJsZVNlbGVjdGlvbih0aGlzLmRvY3VtZW50KSxcbiAgICAgIHN3aXRjaE1hcCgoKSA9PiBFTVBUWSlcbiAgICApO1xuICAgIHJldHVybiBtZXJnZShtb3VzZURvd24sIG1vdXNldXApO1xuICB9XG5cbiAgLy8gUmV0dXJucyBlaXRoZXIgJ3BhZ2VYJyBvciAncGFnZVknIGFjY29yZGluZyB0byBzY3JvbGxiYXIgYXhpc1xuICBhYnN0cmFjdCBnZXQgcGFnZVByb3BlcnR5KCk6IHN0cmluZztcblxuICAvLyBSZXR1cm5zIHRoZSB0cmFjayBzaXplLCBjbGllbnRIZWlnaHQgb3IgY2xpZW50V2lkdGhcbiAgYWJzdHJhY3QgZ2V0IHNpemUoKTogbnVtYmVyO1xuXG4gIC8vIFJldHVybnMgdGhlIHN0YXJ0IG9mZnNldCBlaXRoZXIgJ2NsaWVudFJlY3QudG9wJyBvciAnY2xpZW50UmVjdC5sZWZ0J1xuICBhYnN0cmFjdCBnZXQgb2Zmc2V0KCk6IG51bWJlcjtcblxuICAvLyBHZXQgdHJhY2sgY2xpZW50IHJlY3RcbiAgZ2V0IGNsaWVudFJlY3QoKTogQ2xpZW50UmVjdCB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBjbXA6IE5nU2Nyb2xsYmFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdGVjdGVkIHRyYWNrRWxlbWVudDogSFRNTEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgZG9jdW1lbnQ6IGFueSkge1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gc2Nyb2xsYmFyIHRyYWNrIGlzIGNsaWNrZWRcbiAgICovXG4gIG9uVHJhY2tDbGlja2VkKGU6IGFueSwgdGh1bWJTaXplOiBudW1iZXIsIHNjcm9sbFNpemU6IG51bWJlcik6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIG9mKGUpLnBpcGUoXG4gICAgICBwbHVjayh0aGlzLnBhZ2VQcm9wZXJ0eSksXG4gICAgICAvLyBDYWxjdWxhdGUgc2Nyb2xsVG8gcG9zaXRpb25cbiAgICAgIG1hcCgocGFnZU9mZnNldDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsaWNrT2Zmc2V0ID0gcGFnZU9mZnNldCAtIHRoaXMub2Zmc2V0O1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBjbGlja09mZnNldCAtICh0aHVtYlNpemUgLyAyKTtcbiAgICAgICAgY29uc3QgcmF0aW8gPSBvZmZzZXQgLyB0aGlzLnNpemU7XG4gICAgICAgIHJldHVybiByYXRpbyAqIHNjcm9sbFNpemU7XG4gICAgICB9KSxcbiAgICAgIC8vIFNtb290aCBzY3JvbGwgdG8gcG9zaXRpb25cbiAgICAgIHRhcCgodmFsdWU6IG51bWJlcikgPT4ge1xuICAgICAgICB0aGlzLmNtcC5zY3JvbGxUbyh7XG4gICAgICAgICAgLi4udGhpcy5tYXBUb1Njcm9sbFRvT3B0aW9uKHZhbHVlKSxcbiAgICAgICAgICBkdXJhdGlvbjogY29lcmNlTnVtYmVyUHJvcGVydHkodGhpcy5jbXAudHJhY2tDbGlja1Njcm9sbER1cmF0aW9uKVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBtYXBUb1Njcm9sbFRvT3B0aW9uKHZhbHVlOiBudW1iZXIpOiBTY3JvbGxUb09wdGlvbnM7XG59XG4iXX0=