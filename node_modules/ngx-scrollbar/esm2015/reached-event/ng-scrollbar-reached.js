import { Directive, Optional, Input, Output, NgZone } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { Observable, Subject, Subscription } from 'rxjs';
import { filter, map, tap, distinctUntilChanged } from 'rxjs/operators';
import { NgScrollbar } from 'ngx-scrollbar';
// Uncomment the following line in development mode
// import { NgScrollbar } from '../../src/public-api';
class ReachedFunctions {
    static reachedTop(offset, e) {
        return ReachedFunctions.reached(-e.target.scrollTop, 0, offset);
    }
    static reachedBottom(offset, e) {
        return ReachedFunctions.reached(e.target.scrollTop + e.target.clientHeight, e.target.scrollHeight, offset);
    }
    static reachedStart(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* NEGATED */) {
                return ReachedFunctions.reached(e.target.scrollLeft, 0, offset);
            }
            if (rtlScrollAxisType === 2 /* INVERTED */) {
                return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
            }
            return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
        }
        return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
    }
    static reachedEnd(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* NEGATED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft - e.target.clientWidth), e.target.scrollWidth, offset);
            }
            if (rtlScrollAxisType === 2 /* INVERTED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft + e.target.clientWidth), e.target.scrollWidth, offset);
            }
            return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
        }
        return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
    }
    static reached(currPosition, targetPosition, offset) {
        return currPosition >= targetPosition - offset;
    }
}
class ScrollReached {
    constructor(scrollbar, zone) {
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** offset: Reached offset value in px */
        this.offset = 0;
        /**
         * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
         *
         * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
         */
        this.scrollEvent = new Subject();
        /** subscription: Scrolled event subscription, used to unsubscribe from the event on destroy */
        this.subscription = Subscription.EMPTY;
        /** A stream used to assign the reached output */
        this.reachedEvent = new Observable((subscriber) => this.scrollReached().subscribe(_ => Promise.resolve().then(() => this.zone.run(() => subscriber.next(_)))));
        if (!scrollbar) {
            console.warn('[NgScrollbarReached Directive]: Host element must be an NgScrollbar component.');
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    scrollReached() {
        // current event
        let currEvent;
        return this.scrollEvent.pipe(tap((e) => currEvent = e), 
        // Check if it scroll has reached
        map((e) => this.reached(this.offset, e)), 
        // Distinct until reached value has changed
        distinctUntilChanged(), 
        // Emit only if reached is true
        filter((reached) => reached), 
        // Return scroll event
        map(() => currEvent));
    }
}
ScrollReached.decorators = [
    { type: Directive }
];
ScrollReached.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
ScrollReached.propDecorators = {
    offset: [{ type: Input, args: ['reachedOffset',] }]
};
class VerticalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.subscription = this.scrollbar.verticalScrolled.subscribe(this.scrollEvent);
    }
}
VerticalScrollReached.decorators = [
    { type: Directive }
];
VerticalScrollReached.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
class HorizontalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.subscription = this.scrollbar.horizontalScrolled.subscribe(this.scrollEvent);
    }
}
HorizontalScrollReached.decorators = [
    { type: Directive }
];
HorizontalScrollReached.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
export class NgScrollbarReachedTop extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the top */
        this.reachedTop = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the top (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedTop(offset, e);
    }
}
NgScrollbarReachedTop.decorators = [
    { type: Directive, args: [{
                selector: '[reachedTop], [reached-top]',
            },] }
];
NgScrollbarReachedTop.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
NgScrollbarReachedTop.propDecorators = {
    reachedTop: [{ type: Output }]
};
export class NgScrollbarReachedBottom extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the bottom */
        this.reachedBottom = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the bottom (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedBottom(offset, e);
    }
}
NgScrollbarReachedBottom.decorators = [
    { type: Directive, args: [{
                selector: '[reachedBottom], [reached-bottom]',
            },] }
];
NgScrollbarReachedBottom.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
NgScrollbarReachedBottom.propDecorators = {
    reachedBottom: [{ type: Output }]
};
export class NgScrollbarReachedStart extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the start */
        this.reachedStart = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the start (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedStart(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
}
NgScrollbarReachedStart.decorators = [
    { type: Directive, args: [{
                selector: '[reachedStart], [reached-start]',
            },] }
];
NgScrollbarReachedStart.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: Directionality }
];
NgScrollbarReachedStart.propDecorators = {
    reachedStart: [{ type: Output }]
};
export class NgScrollbarReachedEnd extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the end */
        this.reachedEnd = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the end (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedEnd(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
}
NgScrollbarReachedEnd.decorators = [
    { type: Directive, args: [{
                selector: '[reachedEnd], [reached-end]',
            },] }
];
NgScrollbarReachedEnd.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: Directionality }
];
NgScrollbarReachedEnd.propDecorators = {
    reachedEnd: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctc2Nyb2xsYmFyLXJlYWNoZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtc2Nyb2xsYmFyL3JlYWNoZWQtZXZlbnQvc3JjL25nLXNjcm9sbGJhci1yZWFjaGVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQXFCLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5RixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFbkQsT0FBTyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUMsbURBQW1EO0FBQ25ELHNEQUFzRDtBQUV0RCxNQUFNLGdCQUFnQjtJQUNwQixNQUFNLENBQUMsVUFBVSxDQUFDLE1BQWMsRUFBRSxDQUFNO1FBQ3RDLE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRCxNQUFNLENBQUMsYUFBYSxDQUFDLE1BQWMsRUFBRSxDQUFNO1FBQ3pDLE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzdHLENBQUM7SUFFRCxNQUFNLENBQUMsWUFBWSxDQUFDLE1BQWMsRUFBRSxDQUFNLEVBQUUsU0FBd0IsRUFBRSxpQkFBb0M7UUFDeEcsSUFBSSxTQUFTLEtBQUssS0FBSyxFQUFFO1lBQ3ZCLElBQUksaUJBQWlCLG9CQUE4QixFQUFFO2dCQUNuRCxPQUFPLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDakU7WUFDRCxJQUFJLGlCQUFpQixxQkFBK0IsRUFBRTtnQkFDcEQsT0FBTyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDbEU7WUFDRCxPQUFPLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztTQUMzRztRQUNELE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRCxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQWMsRUFBRSxDQUFNLEVBQUUsU0FBd0IsRUFBRSxpQkFBb0M7UUFDdEcsSUFBSSxTQUFTLEtBQUssS0FBSyxFQUFFO1lBQ3ZCLElBQUksaUJBQWlCLG9CQUE4QixFQUFFO2dCQUNuRCxPQUFPLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQzthQUM5RztZQUNELElBQUksaUJBQWlCLHFCQUErQixFQUFFO2dCQUNwRCxPQUFPLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQzthQUM5RztZQUNELE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ2xFO1FBQ0QsT0FBTyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDNUcsQ0FBQztJQUVELE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBb0IsRUFBRSxjQUFzQixFQUFFLE1BQWM7UUFDekUsT0FBTyxZQUFZLElBQUksY0FBYyxHQUFHLE1BQU0sQ0FBQztJQUNqRCxDQUFDO0NBQ0Y7QUFFRCxNQUNlLGFBQWE7SUFvQjFCLFlBQTRDLFNBQXNCLEVBQVksSUFBWTtRQUE5QyxjQUFTLEdBQVQsU0FBUyxDQUFhO1FBQVksU0FBSSxHQUFKLElBQUksQ0FBUTtRQWxCMUYseUNBQXlDO1FBQ2pCLFdBQU0sR0FBRyxDQUFDLENBQUM7UUFFbkM7Ozs7V0FJRztRQUNPLGdCQUFXLEdBQUcsSUFBSSxPQUFPLEVBQU8sQ0FBQztRQUUzQywrRkFBK0Y7UUFDckYsaUJBQVksR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDO1FBRTVDLGlEQUFpRDtRQUN2QyxpQkFBWSxHQUFHLElBQUksVUFBVSxDQUFDLENBQUMsVUFBMkIsRUFBRSxFQUFFLENBQ3RFLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FDakMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFHMUUsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNkLE9BQU8sQ0FBQyxJQUFJLENBQUMsZ0ZBQWdGLENBQUMsQ0FBQztTQUNoRztJQUNILENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRVMsYUFBYTtRQUNyQixnQkFBZ0I7UUFDaEIsSUFBSSxTQUFjLENBQUM7UUFFbkIsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FDMUIsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO1FBQ3pCLGlDQUFpQztRQUNqQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN4QywyQ0FBMkM7UUFDM0Msb0JBQW9CLEVBQUU7UUFDdEIsK0JBQStCO1FBQy9CLE1BQU0sQ0FBQyxDQUFDLE9BQWdCLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQztRQUNyQyxzQkFBc0I7UUFDdEIsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUNyQixDQUFDO0lBQ0osQ0FBQzs7O1lBOUNGLFNBQVM7OztZQTVDRCxXQUFXLHVCQWlFSyxRQUFRO1lBdEUrQixNQUFNOzs7cUJBcURuRSxLQUFLLFNBQUMsZUFBZTs7QUErQ3hCLE1BQ2UscUJBQXNCLFNBQVEsYUFBYTtJQUN4RCxZQUE0QyxTQUFzQixFQUFZLElBQVk7UUFDeEYsS0FBSyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQURtQixjQUFTLEdBQVQsU0FBUyxDQUFhO1FBQVksU0FBSSxHQUFKLElBQUksQ0FBUTtJQUUxRixDQUFDO0lBRUQsUUFBUTtRQUNOLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBaUIsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ25GLENBQUM7OztZQVJGLFNBQVM7OztZQS9GRCxXQUFXLHVCQWlHSyxRQUFRO1lBdEcrQixNQUFNOztBQStHdEUsTUFDZSx1QkFBd0IsU0FBUSxhQUFhO0lBQzFELFlBQTRDLFNBQXNCLEVBQVksSUFBWTtRQUN4RixLQUFLLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRG1CLGNBQVMsR0FBVCxTQUFTLENBQWE7UUFBWSxTQUFJLEdBQUosSUFBSSxDQUFRO0lBRTFGLENBQUM7SUFFRCxRQUFRO1FBQ04sSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLGtCQUFtQixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDckYsQ0FBQzs7O1lBUkYsU0FBUzs7O1lBMUdELFdBQVcsdUJBNEdLLFFBQVE7WUFqSCtCLE1BQU07O0FBNkh0RSxNQUFNLE9BQU8scUJBQXNCLFNBQVEscUJBQXFCO0lBSzlELFlBQWtDLFNBQXNCLEVBQVksSUFBWTtRQUM5RSxLQUFLLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRFMsY0FBUyxHQUFULFNBQVMsQ0FBYTtRQUFZLFNBQUksR0FBSixJQUFJLENBQVE7UUFIaEYsd0RBQXdEO1FBQzlDLGVBQVUsR0FBb0IsSUFBSSxDQUFDLFlBQVksQ0FBQztJQUkxRCxDQUFDO0lBRUQsUUFBUTtRQUNOLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLE9BQU8sQ0FBQyxNQUFjLEVBQUUsQ0FBTTtRQUN0QyxPQUFPLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDaEQsQ0FBQzs7O1lBdkJGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsNkJBQTZCO2FBQ3hDOzs7WUF2SFEsV0FBVyx1QkE2SEwsUUFBUTtZQWxJeUMsTUFBTTs7O3lCQWdJbkUsTUFBTTs7QUF1QlQsTUFBTSxPQUFPLHdCQUF5QixTQUFRLHFCQUFxQjtJQUtqRSxZQUFrQyxTQUFzQixFQUFZLElBQVk7UUFDOUUsS0FBSyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQURTLGNBQVMsR0FBVCxTQUFTLENBQWE7UUFBWSxTQUFJLEdBQUosSUFBSSxDQUFRO1FBSGhGLDJEQUEyRDtRQUNqRCxrQkFBYSxHQUFvQixJQUFJLENBQUMsWUFBWSxDQUFDO0lBSTdELENBQUM7SUFFRCxRQUFRO1FBQ04sS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFFRDs7OztPQUlHO0lBQ08sT0FBTyxDQUFDLE1BQWMsRUFBRSxDQUFNO1FBQ3RDLE9BQU8sZ0JBQWdCLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNuRCxDQUFDOzs7WUF2QkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxtQ0FBbUM7YUFDOUM7OztZQWpKUSxXQUFXLHVCQXVKTCxRQUFRO1lBNUp5QyxNQUFNOzs7NEJBMEpuRSxNQUFNOztBQXVCVCxNQUFNLE9BQU8sdUJBQXdCLFNBQVEsdUJBQXVCO0lBS2xFLFlBQWtDLFNBQXNCLEVBQVksSUFBWSxFQUFVLEdBQW1CO1FBQzNHLEtBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFEUyxjQUFTLEdBQVQsU0FBUyxDQUFhO1FBQVksU0FBSSxHQUFKLElBQUksQ0FBUTtRQUFVLFFBQUcsR0FBSCxHQUFHLENBQWdCO1FBSDdHLDBEQUEwRDtRQUNoRCxpQkFBWSxHQUFvQixJQUFJLENBQUMsWUFBWSxDQUFDO0lBSTVELENBQUM7SUFFRCxRQUFRO1FBQ04sS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFFRDs7OztPQUlHO0lBQ08sT0FBTyxDQUFDLE1BQWMsRUFBRSxDQUFNO1FBQ3RDLE9BQU8sZ0JBQWdCLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUM1RyxDQUFDOzs7WUF2QkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxpQ0FBaUM7YUFDNUM7OztZQTNLUSxXQUFXLHVCQWlMTCxRQUFRO1lBdEx5QyxNQUFNO1lBQzdELGNBQWM7OzsyQkFtTHBCLE1BQU07O0FBdUJULE1BQU0sT0FBTyxxQkFBc0IsU0FBUSx1QkFBdUI7SUFLaEUsWUFBa0MsU0FBc0IsRUFBWSxJQUFZLEVBQVUsR0FBbUI7UUFDM0csS0FBSyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQURTLGNBQVMsR0FBVCxTQUFTLENBQWE7UUFBWSxTQUFJLEdBQUosSUFBSSxDQUFRO1FBQVUsUUFBRyxHQUFILEdBQUcsQ0FBZ0I7UUFIN0csd0RBQXdEO1FBQzlDLGVBQVUsR0FBb0IsSUFBSSxDQUFDLFlBQVksQ0FBQztJQUkxRCxDQUFDO0lBRUQsUUFBUTtRQUNOLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLE9BQU8sQ0FBQyxNQUFjLEVBQUUsQ0FBTTtRQUN0QyxPQUFPLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDMUcsQ0FBQzs7O1lBdkJGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsNkJBQTZCO2FBQ3hDOzs7WUFyTVEsV0FBVyx1QkEyTUwsUUFBUTtZQWhOeUMsTUFBTTtZQUM3RCxjQUFjOzs7eUJBNk1wQixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBPcHRpb25hbCwgSW5wdXQsIE91dHB1dCwgT25Jbml0LCBPbkRlc3Ryb3ksIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5pbXBvcnQgeyBSdGxTY3JvbGxBeGlzVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBTdWJzY3JpcHRpb24sIFN1YnNjcmliZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgbWFwLCB0YXAsIGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTmdTY3JvbGxiYXIgfSBmcm9tICduZ3gtc2Nyb2xsYmFyJztcbi8vIFVuY29tbWVudCB0aGUgZm9sbG93aW5nIGxpbmUgaW4gZGV2ZWxvcG1lbnQgbW9kZVxuLy8gaW1wb3J0IHsgTmdTY3JvbGxiYXIgfSBmcm9tICcuLi8uLi9zcmMvcHVibGljLWFwaSc7XG5cbmNsYXNzIFJlYWNoZWRGdW5jdGlvbnMge1xuICBzdGF0aWMgcmVhY2hlZFRvcChvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZCgtZS50YXJnZXQuc2Nyb2xsVG9wLCAwLCBvZmZzZXQpO1xuICB9XG5cbiAgc3RhdGljIHJlYWNoZWRCb3R0b20ob2Zmc2V0OiBudW1iZXIsIGU6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoZS50YXJnZXQuc2Nyb2xsVG9wICsgZS50YXJnZXQuY2xpZW50SGVpZ2h0LCBlLnRhcmdldC5zY3JvbGxIZWlnaHQsIG9mZnNldCk7XG4gIH1cblxuICBzdGF0aWMgcmVhY2hlZFN0YXJ0KG9mZnNldDogbnVtYmVyLCBlOiBhbnksIGRpcmVjdGlvbjogJ2x0cicgfCAncnRsJywgcnRsU2Nyb2xsQXhpc1R5cGU6IFJ0bFNjcm9sbEF4aXNUeXBlKTogYm9vbGVhbiB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuTkVHQVRFRCkge1xuICAgICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKGUudGFyZ2V0LnNjcm9sbExlZnQsIDAsIG9mZnNldCk7XG4gICAgICB9XG4gICAgICBpZiAocnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLklOVkVSVEVEKSB7XG4gICAgICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoLWUudGFyZ2V0LnNjcm9sbExlZnQsIDAsIG9mZnNldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKGUudGFyZ2V0LnNjcm9sbExlZnQgKyBlLnRhcmdldC5jbGllbnRXaWR0aCwgZS50YXJnZXQuc2Nyb2xsV2lkdGgsIG9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoLWUudGFyZ2V0LnNjcm9sbExlZnQsIDAsIG9mZnNldCk7XG4gIH1cblxuICBzdGF0aWMgcmVhY2hlZEVuZChvZmZzZXQ6IG51bWJlciwgZTogYW55LCBkaXJlY3Rpb246ICdsdHInIHwgJ3J0bCcsIHJ0bFNjcm9sbEF4aXNUeXBlOiBSdGxTY3JvbGxBeGlzVHlwZSk6IGJvb2xlYW4ge1xuICAgIGlmIChkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICBpZiAocnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLk5FR0FURUQpIHtcbiAgICAgICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZCgtKGUudGFyZ2V0LnNjcm9sbExlZnQgLSBlLnRhcmdldC5jbGllbnRXaWR0aCksIGUudGFyZ2V0LnNjcm9sbFdpZHRoLCBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5JTlZFUlRFRCkge1xuICAgICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKC0oZS50YXJnZXQuc2Nyb2xsTGVmdCArIGUudGFyZ2V0LmNsaWVudFdpZHRoKSwgZS50YXJnZXQuc2Nyb2xsV2lkdGgsIG9mZnNldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKC1lLnRhcmdldC5zY3JvbGxMZWZ0LCAwLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKGUudGFyZ2V0LnNjcm9sbExlZnQgKyBlLnRhcmdldC5jbGllbnRXaWR0aCwgZS50YXJnZXQuc2Nyb2xsV2lkdGgsIG9mZnNldCk7XG4gIH1cblxuICBzdGF0aWMgcmVhY2hlZChjdXJyUG9zaXRpb246IG51bWJlciwgdGFyZ2V0UG9zaXRpb246IG51bWJlciwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gY3VyclBvc2l0aW9uID49IHRhcmdldFBvc2l0aW9uIC0gb2Zmc2V0O1xuICB9XG59XG5cbkBEaXJlY3RpdmUoKVxuYWJzdHJhY3QgY2xhc3MgU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgLyoqIG9mZnNldDogUmVhY2hlZCBvZmZzZXQgdmFsdWUgaW4gcHggKi9cbiAgQElucHV0KCdyZWFjaGVkT2Zmc2V0Jykgb2Zmc2V0ID0gMDtcblxuICAvKipcbiAgICogU3RyZWFtIHRoYXQgZW1pdHMgc2Nyb2xsIGV2ZW50IHdoZW4gYE5nU2Nyb2xsYmFyLnNjcm9sbGVkYCBpcyBpbml0aWFsaXplZC5cbiAgICpcbiAgICogKipOT1RFOioqIFRoaXMgc3ViamVjdCBpcyB1c2VkIHRvIGhvbGQgdGhlIHBsYWNlIG9mIGBOZ1Njcm9sbGJhci5zY3JvbGxlZGAgd2hlbiBpdCdzIG5vdCBpbml0aWFsaXplZCB5ZXRcbiAgICovXG4gIHByb3RlY3RlZCBzY3JvbGxFdmVudCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICAvKiogc3Vic2NyaXB0aW9uOiBTY3JvbGxlZCBldmVudCBzdWJzY3JpcHRpb24sIHVzZWQgdG8gdW5zdWJzY3JpYmUgZnJvbSB0aGUgZXZlbnQgb24gZGVzdHJveSAqL1xuICBwcm90ZWN0ZWQgc3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuXG4gIC8qKiBBIHN0cmVhbSB1c2VkIHRvIGFzc2lnbiB0aGUgcmVhY2hlZCBvdXRwdXQgKi9cbiAgcHJvdGVjdGVkIHJlYWNoZWRFdmVudCA9IG5ldyBPYnNlcnZhYmxlKChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPGFueT4pID0+XG4gICAgdGhpcy5zY3JvbGxSZWFjaGVkKCkuc3Vic2NyaWJlKF8gPT5cbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdGhpcy56b25lLnJ1bigoKSA9PiBzdWJzY3JpYmVyLm5leHQoXykpKSkpO1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZSkge1xuICAgIGlmICghc2Nyb2xsYmFyKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tOZ1Njcm9sbGJhclJlYWNoZWQgRGlyZWN0aXZlXTogSG9zdCBlbGVtZW50IG11c3QgYmUgYW4gTmdTY3JvbGxiYXIgY29tcG9uZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2Nyb2xsUmVhY2hlZCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIC8vIGN1cnJlbnQgZXZlbnRcbiAgICBsZXQgY3VyckV2ZW50OiBhbnk7XG5cbiAgICByZXR1cm4gdGhpcy5zY3JvbGxFdmVudC5waXBlKFxuICAgICAgdGFwKChlKSA9PiBjdXJyRXZlbnQgPSBlKSxcbiAgICAgIC8vIENoZWNrIGlmIGl0IHNjcm9sbCBoYXMgcmVhY2hlZFxuICAgICAgbWFwKChlKSA9PiB0aGlzLnJlYWNoZWQodGhpcy5vZmZzZXQsIGUpKSxcbiAgICAgIC8vIERpc3RpbmN0IHVudGlsIHJlYWNoZWQgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICAvLyBFbWl0IG9ubHkgaWYgcmVhY2hlZCBpcyB0cnVlXG4gICAgICBmaWx0ZXIoKHJlYWNoZWQ6IGJvb2xlYW4pID0+IHJlYWNoZWQpLFxuICAgICAgLy8gUmV0dXJuIHNjcm9sbCBldmVudFxuICAgICAgbWFwKCgpID0+IGN1cnJFdmVudClcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlYWNoZWQob2Zmc2V0OiBudW1iZXIsIGU/OiBhbnkpOiBib29sZWFuO1xufVxuXG5ARGlyZWN0aXZlKClcbmFic3RyYWN0IGNsYXNzIFZlcnRpY2FsU2Nyb2xsUmVhY2hlZCBleHRlbmRzIFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUpIHtcbiAgICBzdXBlcihzY3JvbGxiYXIsIHpvbmUpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnNjcm9sbGJhci52ZXJ0aWNhbFNjcm9sbGVkIS5zdWJzY3JpYmUodGhpcy5zY3JvbGxFdmVudCk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSgpXG5hYnN0cmFjdCBjbGFzcyBIb3Jpem9udGFsU2Nyb2xsUmVhY2hlZCBleHRlbmRzIFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUpIHtcbiAgICBzdXBlcihzY3JvbGxiYXIsIHpvbmUpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnNjcm9sbGJhci5ob3Jpem9udGFsU2Nyb2xsZWQhLnN1YnNjcmliZSh0aGlzLnNjcm9sbEV2ZW50KTtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbcmVhY2hlZFRvcF0sIFtyZWFjaGVkLXRvcF0nLFxufSlcbmV4cG9ydCBjbGFzcyBOZ1Njcm9sbGJhclJlYWNoZWRUb3AgZXh0ZW5kcyBWZXJ0aWNhbFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgdG9wICovXG4gIEBPdXRwdXQoKSByZWFjaGVkVG9wOiBPYnNlcnZhYmxlPGFueT4gPSB0aGlzLnJlYWNoZWRFdmVudDtcblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZSkge1xuICAgIHN1cGVyKHNjcm9sbGJhciwgem9uZSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgdG9wICh2ZXJ0aWNhbGx5KVxuICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcbiAgICogQHBhcmFtIGUgU2Nyb2xsIGV2ZW50XG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZFRvcChvZmZzZXQsIGUpO1xuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tyZWFjaGVkQm90dG9tXSwgW3JlYWNoZWQtYm90dG9tXScsXG59KVxuZXhwb3J0IGNsYXNzIE5nU2Nyb2xsYmFyUmVhY2hlZEJvdHRvbSBleHRlbmRzIFZlcnRpY2FsU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gc2Nyb2xsIGhhcyByZWFjaGVkIHRoZSBib3R0b20gKi9cbiAgQE91dHB1dCgpIHJlYWNoZWRCb3R0b206IE9ic2VydmFibGU8YW55PiA9IHRoaXMucmVhY2hlZEV2ZW50O1xuXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByb3RlY3RlZCBzY3JvbGxiYXI6IE5nU2Nyb2xsYmFyLCBwcm90ZWN0ZWQgem9uZTogTmdab25lKSB7XG4gICAgc3VwZXIoc2Nyb2xsYmFyLCB6b25lKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc2Nyb2xsIGhhcyByZWFjaGVkIHRoZSBib3R0b20gKHZlcnRpY2FsbHkpXG4gICAqIEBwYXJhbSBvZmZzZXQgU2Nyb2xsIG9mZnNldFxuICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcbiAgICovXG4gIHByb3RlY3RlZCByZWFjaGVkKG9mZnNldDogbnVtYmVyLCBlOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkQm90dG9tKG9mZnNldCwgZSk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3JlYWNoZWRTdGFydF0sIFtyZWFjaGVkLXN0YXJ0XScsXG59KVxuZXhwb3J0IGNsYXNzIE5nU2Nyb2xsYmFyUmVhY2hlZFN0YXJ0IGV4dGVuZHMgSG9yaXpvbnRhbFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgc3RhcnQgKi9cbiAgQE91dHB1dCgpIHJlYWNoZWRTdGFydDogT2JzZXJ2YWJsZTxhbnk+ID0gdGhpcy5yZWFjaGVkRXZlbnQ7XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUsIHByaXZhdGUgZGlyOiBEaXJlY3Rpb25hbGl0eSkge1xuICAgIHN1cGVyKHNjcm9sbGJhciwgem9uZSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgc3RhcnQgKGhvcml6b250YWxseSlcbiAgICogQHBhcmFtIG9mZnNldCBTY3JvbGwgb2Zmc2V0XG4gICAqIEBwYXJhbSBlIFNjcm9sbCBldmVudFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWNoZWQob2Zmc2V0OiBudW1iZXIsIGU6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWRTdGFydChvZmZzZXQsIGUsIHRoaXMuZGlyLnZhbHVlLCB0aGlzLnNjcm9sbGJhci5tYW5hZ2VyLnJ0bFNjcm9sbEF4aXNUeXBlKTtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbcmVhY2hlZEVuZF0sIFtyZWFjaGVkLWVuZF0nLFxufSlcbmV4cG9ydCBjbGFzcyBOZ1Njcm9sbGJhclJlYWNoZWRFbmQgZXh0ZW5kcyBIb3Jpem9udGFsU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gc2Nyb2xsIGhhcyByZWFjaGVkIHRoZSBlbmQgKi9cbiAgQE91dHB1dCgpIHJlYWNoZWRFbmQ6IE9ic2VydmFibGU8YW55PiA9IHRoaXMucmVhY2hlZEV2ZW50O1xuXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByb3RlY3RlZCBzY3JvbGxiYXI6IE5nU2Nyb2xsYmFyLCBwcm90ZWN0ZWQgem9uZTogTmdab25lLCBwcml2YXRlIGRpcjogRGlyZWN0aW9uYWxpdHkpIHtcbiAgICBzdXBlcihzY3JvbGxiYXIsIHpvbmUpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIGVuZCAoaG9yaXpvbnRhbGx5KVxuICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcbiAgICogQHBhcmFtIGUgU2Nyb2xsIGV2ZW50XG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZEVuZChvZmZzZXQsIGUsIHRoaXMuZGlyLnZhbHVlLCB0aGlzLnNjcm9sbGJhci5tYW5hZ2VyLnJ0bFNjcm9sbEF4aXNUeXBlKTtcbiAgfVxufVxuIl19