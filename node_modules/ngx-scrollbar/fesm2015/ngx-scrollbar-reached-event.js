import { Directive, Optional, NgZone, Input, Output, NgModule } from '@angular/core';
import { Directionality, BidiModule } from '@angular/cdk/bidi';
import { NgScrollbar, NgScrollbarModule } from 'ngx-scrollbar';
import { Subject, Subscription, Observable } from 'rxjs';
import { tap, map, distinctUntilChanged, filter } from 'rxjs/operators';

// Uncomment the following line in development mode
// import { NgScrollbar } from '../../src/public-api';
class ReachedFunctions {
    static reachedTop(offset, e) {
        return ReachedFunctions.reached(-e.target.scrollTop, 0, offset);
    }
    static reachedBottom(offset, e) {
        return ReachedFunctions.reached(e.target.scrollTop + e.target.clientHeight, e.target.scrollHeight, offset);
    }
    static reachedStart(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* NEGATED */) {
                return ReachedFunctions.reached(e.target.scrollLeft, 0, offset);
            }
            if (rtlScrollAxisType === 2 /* INVERTED */) {
                return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
            }
            return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
        }
        return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
    }
    static reachedEnd(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* NEGATED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft - e.target.clientWidth), e.target.scrollWidth, offset);
            }
            if (rtlScrollAxisType === 2 /* INVERTED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft + e.target.clientWidth), e.target.scrollWidth, offset);
            }
            return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
        }
        return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
    }
    static reached(currPosition, targetPosition, offset) {
        return currPosition >= targetPosition - offset;
    }
}
class ScrollReached {
    constructor(scrollbar, zone) {
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** offset: Reached offset value in px */
        this.offset = 0;
        /**
         * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
         *
         * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
         */
        this.scrollEvent = new Subject();
        /** subscription: Scrolled event subscription, used to unsubscribe from the event on destroy */
        this.subscription = Subscription.EMPTY;
        /** A stream used to assign the reached output */
        this.reachedEvent = new Observable((subscriber) => this.scrollReached().subscribe(_ => Promise.resolve().then(() => this.zone.run(() => subscriber.next(_)))));
        if (!scrollbar) {
            console.warn('[NgScrollbarReached Directive]: Host element must be an NgScrollbar component.');
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    scrollReached() {
        // current event
        let currEvent;
        return this.scrollEvent.pipe(tap((e) => currEvent = e), 
        // Check if it scroll has reached
        map((e) => this.reached(this.offset, e)), 
        // Distinct until reached value has changed
        distinctUntilChanged(), 
        // Emit only if reached is true
        filter((reached) => reached), 
        // Return scroll event
        map(() => currEvent));
    }
}
ScrollReached.decorators = [
    { type: Directive }
];
ScrollReached.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
ScrollReached.propDecorators = {
    offset: [{ type: Input, args: ['reachedOffset',] }]
};
class VerticalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.subscription = this.scrollbar.verticalScrolled.subscribe(this.scrollEvent);
    }
}
VerticalScrollReached.decorators = [
    { type: Directive }
];
VerticalScrollReached.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
class HorizontalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.subscription = this.scrollbar.horizontalScrolled.subscribe(this.scrollEvent);
    }
}
HorizontalScrollReached.decorators = [
    { type: Directive }
];
HorizontalScrollReached.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
class NgScrollbarReachedTop extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the top */
        this.reachedTop = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the top (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedTop(offset, e);
    }
}
NgScrollbarReachedTop.decorators = [
    { type: Directive, args: [{
                selector: '[reachedTop], [reached-top]',
            },] }
];
NgScrollbarReachedTop.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
NgScrollbarReachedTop.propDecorators = {
    reachedTop: [{ type: Output }]
};
class NgScrollbarReachedBottom extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the bottom */
        this.reachedBottom = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the bottom (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedBottom(offset, e);
    }
}
NgScrollbarReachedBottom.decorators = [
    { type: Directive, args: [{
                selector: '[reachedBottom], [reached-bottom]',
            },] }
];
NgScrollbarReachedBottom.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
NgScrollbarReachedBottom.propDecorators = {
    reachedBottom: [{ type: Output }]
};
class NgScrollbarReachedStart extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the start */
        this.reachedStart = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the start (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedStart(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
}
NgScrollbarReachedStart.decorators = [
    { type: Directive, args: [{
                selector: '[reachedStart], [reached-start]',
            },] }
];
NgScrollbarReachedStart.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: Directionality }
];
NgScrollbarReachedStart.propDecorators = {
    reachedStart: [{ type: Output }]
};
class NgScrollbarReachedEnd extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the end */
        this.reachedEnd = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the end (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedEnd(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
}
NgScrollbarReachedEnd.decorators = [
    { type: Directive, args: [{
                selector: '[reachedEnd], [reached-end]',
            },] }
];
NgScrollbarReachedEnd.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: Directionality }
];
NgScrollbarReachedEnd.propDecorators = {
    reachedEnd: [{ type: Output }]
};

class NgScrollbarReachedModule {
}
NgScrollbarReachedModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    NgScrollbarModule,
                    BidiModule
                ],
                declarations: [
                    NgScrollbarReachedTop,
                    NgScrollbarReachedBottom,
                    NgScrollbarReachedStart,
                    NgScrollbarReachedEnd
                ],
                exports: [
                    NgScrollbarReachedTop,
                    NgScrollbarReachedBottom,
                    NgScrollbarReachedStart,
                    NgScrollbarReachedEnd
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { NgScrollbarReachedBottom, NgScrollbarReachedEnd, NgScrollbarReachedModule, NgScrollbarReachedStart, NgScrollbarReachedTop };
//# sourceMappingURL=ngx-scrollbar-reached-event.js.map
